-- MySQL dump 10.13  Distrib 5.7.20, for Linux (x86_64)
--
-- Host: localhost    Database: robocode
-- ------------------------------------------------------
-- Server version 5.7.20-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `battlestat`
--
CREATE DATABASE robocode;
USE robocode;
DROP TABLE IF EXISTS `battlestat`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `battlestat` (
  `Rank` INT(11) DEFAULT NULL,
  `RobotName` VARCHAR(30) DEFAULT NULL,
  `TotalScore` INT(11) DEFAULT NULL,
  `PercentofTotal` INT(11) DEFAULT NULL,
  `Survival` INT(11) DEFAULT NULL,
  `SurvivalBonus` INT(11) DEFAULT NULL,
  `BulletDmg` INT(11) DEFAULT NULL,
  `BulletBonus` INT(11) DEFAULT NULL,
  `RamDmg2` INT(11) DEFAULT NULL,
  `RamBonus` INT(11) DEFAULT NULL,
  `1sts` INT(11) DEFAULT NULL,
  `2nds` INT(11) DEFAULT NULL,
  `3rds` INT(11) DEFAULT NULL
) ENGINE=INNODB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `battlestat`
--

LOCK TABLES `battlestat` WRITE;
/*!40000 ALTER TABLE `battlestat` DISABLE KEYS */;
/*!40000 ALTER TABLE `battlestat` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `relationship`
--

DROP TABLE IF EXISTS `relationship`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `relationship` (
  `relationshipid` INT(11) NOT NULL AUTO_INCREMENT,
  `robotid` VARCHAR(45) NOT NULL,
  `userid` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`relationshipid`)
) ENGINE=INNODB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `relationship`
--

LOCK TABLES `relationship` WRITE;
/*!40000 ALTER TABLE `relationship` DISABLE KEYS */;
INSERT INTO `relationship` VALUES (1,'Interactive_v2','a'),(2,'Interactive','a'),(3,'Crazy','b'),(4,'Fire','a'),(5,'Arun Robot','Aayush'),(6,'Crazy','admin'),(7,'SittingDuck','admin');
/*!40000 ALTER TABLE `relationship` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `robot`
--

DROP TABLE IF EXISTS `robot`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `robot` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `userID` varchar(80) DEFAULT NULL,
  `packageID` varchar(80) DEFAULT NULL,
  `robotID` varchar(80) DEFAULT NULL,
  `dataaccess` varchar(4) DEFAULT NULL,
  `filepath` longtext,
  `CreatedDate` varchar(200) DEFAULT NULL,
  `UpdatedDate` varchar(200) DEFAULT NULL,
  `RobotCode` longtext,
  `file` longblob,
  `org` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=85 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `robot`
--

LOCK TABLES `robot` WRITE;
/*!40000 ALTER TABLE `robot` DISABLE KEYS */;
INSERT INTO `robot` VALUES (1,'a','Package1','Crazy','Y','C:/robocode/robots/sample/Crazy.java','Mon Jan 25 10:27:35 CST 2016','Fri Sep 23 17:06:41 CDT 2016','  /**Hi\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n\r\n\r\n\r\n        \r\n    \r\n        \r\n    \r\n        \r\n    \r\n \r\n     \r\n    \r\n   \r\n \r\n \r\n','  /**Hi\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n\r\n\r\n\r\n        \r\n    \r\n        \r\n    \r\n        \r\n    \r\n \r\n     \r\n    \r\n   \r\n \r\n \r\n','org1'),(2,'User1','Package1','Corners','Y','C:/robocode/robots/sample/Corners.java','Mon Jan 25 10:27:35 CST 2016','Mon Feb 01 14:44:42 CST 2016','/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.DeathEvent;\r\nimport robocode.Robot;\r\nimport robocode.ScannedRobotEvent;\r\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Corners - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves to a corner, then swings the gun back and forth.\r\n * If it dies, it tries a new corner in the next round.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Corners extends Robot {\r\n int others; // Number of other robots in the game\r\n static int corner = 0; // Which corner we are currently using\r\n // static so that it keeps it between rounds.\r\n boolean stopWhenSeeRobot = false; // See goCorner()\r\n\r\n /**\r\n  * run:  Corners\' main run function.\r\n  */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(Color.red);\r\n    setGunColor(Color.black);\r\n   setRadarColor(Color.yellow);\r\n    setBulletColor(Color.green);\r\n    setScanColor(Color.green);\r\n\r\n    // Save # of other bots\r\n   others = getOthers();\r\n\r\n   // Move to a corner\r\n   goCorner();\r\n\r\n   // Initialize gun turn speed to 3\r\n   int gunIncrement = 3;\r\n\r\n   // Spin gun back and forth\r\n    while (true) {\r\n      for (int i = 0; i < 30; i++) {\r\n        turnGunLeft(gunIncrement);\r\n      }\r\n     gunIncrement *= -1;\r\n   }\r\n }\r\n\r\n /**\r\n  * goCorner:  A very inefficient way to get to a corner.  Can you do better?\r\n   */\r\n public void goCorner() {\r\n    // We don\'t want to stop when we\'re just turning...\r\n   stopWhenSeeRobot = false;\r\n   // turn to face the wall to the \"right\" of our desired corner.\r\n    turnRight(normalRelativeAngleDegrees(corner - getHeading()));\r\n   // Ok, now we don\'t want to crash into any robot in our way...\r\n   stopWhenSeeRobot = true;\r\n    // Move to that wall\r\n    ahead(5000);\r\n    // Turn to face the corner\r\n    turnLeft(90);\r\n   // Move to the corner\r\n   ahead(5000);\r\n    // Turn gun to starting point\r\n   turnGunLeft(90);\r\n  }\r\n\r\n /**\r\n  * onScannedRobot:  Stop and fire!\r\n   */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   // Should we stop, or just fire?\r\n    if (stopWhenSeeRobot) {\r\n     // Stop everything!  You can safely call stop multiple times.\r\n     stop();\r\n     // Call our custom firing method\r\n      smartFire(e.getDistance());\r\n     // Look for another robot.\r\n      // NOTE:  If you call scan() inside onScannedRobot, and it sees a robot,\r\n      // the game will interrupt the event handler and start it over\r\n      scan();\r\n     // We won\'t get here if we saw another robot.\r\n      // Okay, we didn\'t see another robot... start moving or turning again.\r\n     resume();\r\n   } else {\r\n      smartFire(e.getDistance());\r\n   }\r\n }\r\n\r\n /**\r\n  * smartFire:  Custom fire method that determines firepower based on distance.\r\n   *\r\n   * @param robotDistance the distance to the robot to fire at\r\n   */\r\n public void smartFire(double robotDistance) {\r\n   if (robotDistance > 200 || getEnergy() < 15) {\r\n      fire(1);\r\n    } else if (robotDistance > 50) {\r\n      fire(2);\r\n    } else {\r\n      fire(3);\r\n    }\r\n }\r\n\r\n /**\r\n  * onDeath:  We died.  Decide whether to try a different corner next game.\r\n   */\r\n public void onDeath(DeathEvent e) {\r\n   // Well, others should never be 0, but better safe than sorry.\r\n    if (others == 0) {\r\n      return;\r\n   }\r\n\r\n   // If 75% of the robots are still alive when we die, we\'ll switch corners.\r\n   if ((others - getOthers()) / (double) others < .75) {\r\n     corner += 90;\r\n     if (corner == 270) {\r\n        corner = -90;\r\n     }\r\n     out.println(\"I died and did poorly... switching corner to \" + corner);\r\n    } else {\r\n      out.println(\"I died but did well.  I will still use corner \" + corner);\r\n   }\r\n }\r\n}\r\n\r\n\r\n \r\n    \r\n\r\n \r\n    \r\n','/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n  boolean movingForward;\r\n\r\n  /**\r\n  * run: Crazy\'s main run function\r\n   */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(new Color(0, 200, 0));\r\n   setGunColor(new Color(0, 150, 50));\r\n   setRadarColor(new Color(0, 100, 100));\r\n    setBulletColor(new Color(255, 255, 100));\r\n   setScanColor(new Color(255, 200, 200));\r\n\r\n   // Loop forever\r\n   while (true) {\r\n      // Tell the game we will want to move ahead 40000 -- some large number\r\n      setAhead(40000);\r\n      movingForward = true;\r\n     // Tell the game we will want to turn right 90\r\n      setTurnRight(90);\r\n     // At this point, we have indicated to the game that *when we do something*,\r\n      // we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n      // It is important to realize we have not done anything yet!\r\n      // In order to actually move, we\'ll want to call a method that\r\n     // takes real time, such as waitFor.\r\n      // waitFor actually starts the action -- we start moving and turning.\r\n     // It will not return until we have finished turning.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // Note:  We are still moving ahead now, but the turn is complete.\r\n      // Now we\'ll turn the other way...\r\n     setTurnLeft(180);\r\n     // ... and wait for the turn to finish ...\r\n      waitFor(new TurnCompleteCondition(this));\r\n     // ... then the other way ...\r\n     setTurnRight(180);\r\n      // .. and wait for that turn to finish.\r\n     waitFor(new TurnCompleteCondition(this));\r\n     // then back to the top to do it all again\r\n    }\r\n }\r\n\r\n /**\r\n  * onHitWall:  Handle collision with wall.\r\n   */\r\n public void onHitWall(HitWallEvent e) {\r\n   // Bounce off!\r\n    reverseDirection();\r\n }\r\n\r\n /**\r\n  * reverseDirection:  Switch from ahead to back & vice versa\r\n   */\r\n public void reverseDirection() {\r\n    if (movingForward) {\r\n      setBack(40000);\r\n     movingForward = false;\r\n    } else {\r\n      setAhead(40000);\r\n      movingForward = true;\r\n   }\r\n }\r\n\r\n /**\r\n  * onScannedRobot:  Fire!\r\n  */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   fire(1);\r\n  }\r\n\r\n /**\r\n  * onHitRobot:  Back up!\r\n   */\r\n public void onHitRobot(HitRobotEvent e) {\r\n   // If we\'re moving the other robot, reverse!\r\n   if (e.isMyFault()) {\r\n      reverseDirection();\r\n   }\r\n }\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.DeathEvent;\r\nimport robocode.Robot;\r\nimport robocode.ScannedRobotEvent;\r\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Corners - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves to a corner, then swings the gun back and forth.\r\n * If it dies, it tries a new corner in the next round.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Corners extends Robot {\r\n int others; // Number of other robots in the game\r\n static int corner = 0; // Which corner we are currently using\r\n // static so that it keeps it between rounds.\r\n boolean stopWhenSeeRobot = false; // See goCorner()\r\n\r\n /**\r\n  * run:  Corners\' main run function.\r\n  */\r\n public void run() {\r\n   // Set colors\r\n   setBodyColor(Color.red);\r\n    setGunColor(Color.black);\r\n   setRadarColor(Color.yellow);\r\n    setBulletColor(Color.green);\r\n    setScanColor(Color.green);\r\n\r\n    // Save # of other bots\r\n   others = getOthers();\r\n\r\n   // Move to a corner\r\n   goCorner();\r\n\r\n   // Initialize gun turn speed to 3\r\n   int gunIncrement = 3;\r\n\r\n   // Spin gun back and forth\r\n    while (true) {\r\n      for (int i = 0; i < 30; i++) {\r\n        turnGunLeft(gunIncrement);\r\n      }\r\n     gunIncrement *= -1;\r\n   }\r\n }\r\n\r\n /**\r\n  * goCorner:  A very inefficient way to get to a corner.  Can you do better?\r\n   */\r\n public void goCorner() {\r\n    // We don\'t want to stop when we\'re just turning...\r\n   stopWhenSeeRobot = false;\r\n   // turn to face the wall to the \"right\" of our desired corner.\r\n    turnRight(normalRelativeAngleDegrees(corner - getHeading()));\r\n   // Ok, now we don\'t want to crash into any robot in our way...\r\n   stopWhenSeeRobot = true;\r\n    // Move to that wall\r\n    ahead(5000);\r\n    // Turn to face the corner\r\n    turnLeft(90);\r\n   // Move to the corner\r\n   ahead(5000);\r\n    // Turn gun to starting point\r\n   turnGunLeft(90);\r\n  }\r\n\r\n /**\r\n  * onScannedRobot:  Stop and fire!\r\n   */\r\n public void onScannedRobot(ScannedRobotEvent e) {\r\n   // Should we stop, or just fire?\r\n    if (stopWhenSeeRobot) {\r\n     // Stop everything!  You can safely call stop multiple times.\r\n     stop();\r\n     // Call our custom firing method\r\n      smartFire(e.getDistance());\r\n     // Look for another robot.\r\n      // NOTE:  If you call scan() inside onScannedRobot, and it sees a robot,\r\n      // the game will interrupt the event handler and start it over\r\n      scan();\r\n     // We won\'t get here if we saw another robot.\r\n      // Okay, we didn\'t see another robot... start moving or turning again.\r\n     resume();\r\n   } else {\r\n      smartFire(e.getDistance());\r\n   }\r\n }\r\n\r\n /**\r\n  * smartFire:  Custom fire method that determines firepower based on distance.\r\n   *\r\n   * @param robotDistance the distance to the robot to fire at\r\n   */\r\n public void smartFire(double robotDistance) {\r\n   if (robotDistance > 200 || getEnergy() < 15) {\r\n      fire(1);\r\n    } else if (robotDistance > 50) {\r\n      fire(2);\r\n    } else {\r\n      fire(3);\r\n    }\r\n }\r\n\r\n /**\r\n  * onDeath:  We died.  Decide whether to try a different corner next game.\r\n   */\r\n public void onDeath(DeathEvent e) {\r\n   // Well, others should never be 0, but better safe than sorry.\r\n    if (others == 0) {\r\n      return;\r\n   }\r\n\r\n   // If 75% of the robots are still alive when we die, we\'ll switch corners.\r\n   if ((others - getOthers()) / (double) others < .75) {\r\n     corner += 90;\r\n     if (corner == 270) {\r\n        corner = -90;\r\n     }\r\n     out.println(\"I died and did poorly... switching corner to \" + corner);\r\n    } else {\r\n      out.println(\"I died but did well.  I will still use corner \" + corner);\r\n   }\r\n }\r\n}\r\n\r\n\r\n \r\n    \r\n\r\n \r\n    \r\n','org2'),(6,'John','Package1','MyFirstJuniorRobot','Y','C:/robocode/robots/sample/MyFirstJuniorRobot.java','','Mon Jan 25 10:03:29 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.JuniorRobot;\n\n\n/**\n * MyFirstJuniorRobot - a sample robot by Flemming N. Larsen\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end\n * when it cannot see any enemy robot. When the robot sees and enemy\n * robot, it will immediately turn the gun and fire at it.\n *\n * @author Flemming N. Larsen (original)\n */\npublic class MyFirstJuniorRobot extends JuniorRobot {\n\n /**\n  * MyFirstJuniorRobot\'s run method - Seesaw as default\n  */\n public void run() {\n   // Set robot colors\n   setColors(green, black, blue);\n\n    // Seesaw forever\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n /**\n  * When we see a robot, turn the gun towards it and fire\n   */\n public void onScannedRobot() {\n    // Turn gun to point at the scanned robot\n   turnGunTo(scannedAngle);\n\n    // Fire!\n    fire(1);\n  }\n\n /**\n  * We were hit!  Turn and move perpendicular to the bullet,\n  * so our seesaw might avoid a future shot.\n  */\n public void onHitByBullet() {\n   // Move ahead 100 and in the same time turn left papendicular to the bullet\n   turnAheadLeft(100, 90 - hitByBulletBearing);\n  }\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.JuniorRobot;\n\n\n/**\n * MyFirstJuniorRobot - a sample robot by Flemming N. Larsen\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end\n * when it cannot see any enemy robot. When the robot sees and enemy\n * robot, it will immediately turn the gun and fire at it.\n *\n * @author Flemming N. Larsen (original)\n */\npublic class MyFirstJuniorRobot extends JuniorRobot {\n\n /**\n  * MyFirstJuniorRobot\'s run method - Seesaw as default\n  */\n public void run() {\n   // Set robot colors\n   setColors(green, black, blue);\n\n    // Seesaw forever\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n /**\n  * When we see a robot, turn the gun towards it and fire\n   */\n public void onScannedRobot() {\n    // Turn gun to point at the scanned robot\n   turnGunTo(scannedAngle);\n\n    // Fire!\n    fire(1);\n  }\n\n /**\n  * We were hit!  Turn and move perpendicular to the bullet,\n  * so our seesaw might avoid a future shot.\n  */\n public void onHitByBullet() {\n   // Move ahead 100 and in the same time turn left papendicular to the bullet\n   turnAheadLeft(100, 90 - hitByBulletBearing);\n  }\n}\n',NULL),(7,'Arun','Package1','MyFirstRobot','Y','C:/robocode/robots/sample/MyFirstRobot.java','','Tue Jan 26 11:27:43 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * MyFirstRobot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end.\n *\n * @author Mathew A. Nelson (original)\n */\npublic class MyFirstRobot extends Robot {\n\n /**\n  * MyFirstRobot\'s run method - Seesaw\n   */\n public void run() {\n\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n /**\n  * Fire when we see a robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n /**\n  * We were hit!  Turn perpendicular to the bullet,\n   * so our seesaw might avoid a future shot.\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n}\n\n\n\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * MyFirstRobot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end.\n *\n * @author Mathew A. Nelson (original)\n */\npublic class MyFirstRobot extends Robot {\n\n /**\n  * MyFirstRobot\'s run method - Seesaw\n   */\n public void run() {\n\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n /**\n  * Fire when we see a robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n /**\n  * We were hit!  Turn perpendicular to the bullet,\n   * so our seesaw might avoid a future shot.\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n}                        \n\n',NULL),(8,'admin','Package2','PaintingRobot','Y','C:/robocode/robots/sample/PaintingRobot.java','','Fri Jan 22 17:33:56 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * PaintingRobot - a sample robot that demonstrates the onPaint() and\n * getGraphics() methods.\n * Also demonstrate feature of debugging properties on RobotDialog\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end.\n * When painting is enabled for this robot, a red circle will be painted\n * around this robot.\n *\n * @author Stefan Westen (original SGSample)\n * @author Pavel Savara (contributor)\n */\npublic class PaintingRobot extends Robot {\n\n /**\n  * PaintingRobot\'s run method - Seesaw\n  */\n public void run() {\n   while (true) {\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n\n /**\n  * Fire when we see a robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // demonstrate feature of debugging properties on RobotDialog\n   setDebugProperty(\"lastScannedRobot\", e.getName()   \" at \"   e.getBearing()   \" degrees at time \"   getTime());\n    \n    fire(1);\n  }\n\n /**\n  * We were hit!  Turn perpendicular to the bullet,\n   * so our seesaw might avoid a future shot.\n  * In addition, draw orange circles where we were hit.\n   */\n public void onHitByBullet(HitByBulletEvent e) {\n   // demonstrate feature of debugging properties on RobotDialog\n   setDebugProperty(\"lastHitBy\", e.getName()   \" with power of bullet \"   e.getPower()   \" at time \"   getTime());\n\n   // show how to remove debugging property\n    setDebugProperty(\"lastScannedRobot\", null);\n\n   // gebugging by painting to battle view\n   Graphics2D g = getGraphics();\n\n   g.setColor(Color.orange);\n   g.drawOval((int) (getX() - 55), (int) (getY() - 55), 110, 110);\n   g.drawOval((int) (getX() - 56), (int) (getY() - 56), 112, 112);\n   g.drawOval((int) (getX() - 59), (int) (getY() - 59), 118, 118);\n   g.drawOval((int) (getX() - 60), (int) (getY() - 60), 120, 120);\n\n   turnLeft(90 - e.getBearing());\n  }\n\n /**\n  * Paint a red circle around our PaintingRobot\n   */\n public void onPaint(Graphics2D g) {\n   g.setColor(Color.red);\n    g.drawOval((int) (getX() - 50), (int) (getY() - 50), 100, 100);\n   g.setColor(new Color(0, 0xFF, 0, 30));\n    g.fillOval((int) (getX() - 60), (int) (getY() - 60), 120, 120);\n }\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * PaintingRobot - a sample robot that demonstrates the onPaint() and\n * getGraphics() methods.\n * Also demonstrate feature of debugging properties on RobotDialog\n * <p/>\n * Moves in a seesaw motion, and spins the gun around at each end.\n * When painting is enabled for this robot, a red circle will be painted\n * around this robot.\n *\n * @author Stefan Westen (original SGSample)\n * @author Pavel Savara (contributor)\n */\npublic class PaintingRobot extends Robot {\n\n  /**\n  * PaintingRobot\'s run method - Seesaw\n  */\n public void run() {\n   while (true) {\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n\n /**\n  * Fire when we see a robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // demonstrate feature of debugging properties on RobotDialog\n   setDebugProperty(\"lastScannedRobot\", e.getName() + \" at \" + e.getBearing() + \" degrees at time \" + getTime());\n    \n    fire(1);\n  }\n\n /**\n  * We were hit!  Turn perpendicular to the bullet,\n   * so our seesaw might avoid a future shot.\n  * In addition, draw orange circles where we were hit.\n   */\n public void onHitByBullet(HitByBulletEvent e) {\n   // demonstrate feature of debugging properties on RobotDialog\n   setDebugProperty(\"lastHitBy\", e.getName() + \" with power of bullet \" + e.getPower() + \" at time \" + getTime());\n\n   // show how to remove debugging property\n    setDebugProperty(\"lastScannedRobot\", null);\n\n   // gebugging by painting to battle view\n   Graphics2D g = getGraphics();\n\n   g.setColor(Color.orange);\n   g.drawOval((int) (getX() - 55), (int) (getY() - 55), 110, 110);\n   g.drawOval((int) (getX() - 56), (int) (getY() - 56), 112, 112);\n   g.drawOval((int) (getX() - 59), (int) (getY() - 59), 118, 118);\n   g.drawOval((int) (getX() - 60), (int) (getY() - 60), 120, 120);\n\n   turnLeft(90 - e.getBearing());\n  }\n\n /**\n  * Paint a red circle around our PaintingRobot\n   */\n public void onPaint(Graphics2D g) {\n   g.setColor(Color.red);\n    g.drawOval((int) (getX() - 50), (int) (getY() - 50), 100, 100);\n   g.setColor(new Color(0, 0xFF, 0, 30));\n    g.fillOval((int) (getX() - 60), (int) (getY() - 60), 120, 120);\n }\n}\n',NULL),(9,'User','Package2','RamFire','Y','C:/robocode/robots/sample/RamFire.java','','Tue Jan 26 11:34:09 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * RamFire - a sample robot by Mathew Nelson.\n * <p/>\n * Drives at robots trying to ram them.\n * Fires when it hits them.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class RamFire extends Robot {\n int turnDirection = 1; // Clockwise or counterclockwise\n\n /**\n  * run: Spin around looking for a target\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.lightGray);\n    setGunColor(Color.gray);\n    setRadarColor(Color.darkGray);\n\n    while (true) {\n      turnRight(5 * turnDirection);\n   }\n }\n\n /**\n  * onScannedRobot:  We have a target.  Go get it.\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n\n   if (e.getBearing() >= 0) {\n      turnDirection = 1;\n    } else {\n      turnDirection = -1;\n   }\n\n   turnRight(e.getBearing());\n    ahead(e.getDistance());\n   scan(); // Might want to move ahead again!\n  }\n\n /**\n  * onHitRobot:  Turn to face robot, fire hard, and ram him again!\n  */\n public void onHitRobot(HitRobotEvent e) {\n   if (e.getBearing() >= 0) {\n      turnDirection = 1;\n    } else {\n      turnDirection = -1;\n   }\n   turnRight(e.getBearing());\n\n    // Determine a shot that won\'t kill the robot...\n   // We want to ram him instead for bonus points\n    if (e.getEnergy() > 16) {\n     fire(3);\n    } else if (e.getEnergy() > 10) {\n      fire(2);\n    } else if (e.getEnergy() > 4) {\n     fire(1);\n    } else if (e.getEnergy() > 2) {\n     fire(.5);\n   } else if (e.getEnergy() > .4) {\n      fire(.1);\n   }\n   ahead(40); // Ram him again!\n  }\n}\n\n\n\n\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * RamFire - a sample robot by Mathew Nelson.\n * <p/>\n * Drives at robots trying to ram them.\n * Fires when it hits them.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class RamFire extends Robot {\n int turnDirection = 1; // Clockwise or counterclockwise\n\n /**\n  * run: Spin around looking for a target\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.lightGray);\n    setGunColor(Color.gray);\n    setRadarColor(Color.darkGray);\n\n    while (true) {\n      turnRight(5 * turnDirection);\n   }\n }\n\n /**\n  * onScannedRobot:  We have a target.  Go get it.\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n\n   if (e.getBearing() >= 0) {\n      turnDirection = 1;\n    } else {\n      turnDirection = -1;\n   }\n\n   turnRight(e.getBearing());\n    ahead(e.getDistance() + 5);\n   scan(); // Might want to move ahead again!\n  }\n\n /**\n  * onHitRobot:  Turn to face robot, fire hard, and ram him again!\n  */\n public void onHitRobot(HitRobotEvent e) {\n   if (e.getBearing() >= 0) {\n      turnDirection = 1;\n    } else {\n      turnDirection = -1;\n   }\n   turnRight(e.getBearing());\n\n    // Determine a shot that won\'t kill the robot...\n   // We want to ram him instead for bonus points\n    if (e.getEnergy() > 16) {\n     fire(3);\n    } else if (e.getEnergy() > 10) {\n      fire(2);\n    } else if (e.getEnergy() > 4) {\n     fire(1);\n    } else if (e.getEnergy() > 2) {\n     fire(.5);\n   } else if (e.getEnergy() > .4) {\n      fire(.1);\n   }\n   ahead(40); // Ram him again!\n  }\n}\n',NULL),(10,'User','Package2','SittingDuck','Y','C:/robocode/robots/sample/SittingDuck.java','','Fri Jan 22 17:45:16 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.RobocodeFileOutputStream;\n\nimport java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\n\n/**\n * SittingDuck - a sample robot by Mathew Nelson.\n * <p/>\n * Along with sitting still doing nothing, this robot demonstrates persistency.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n * @author Andrew Magargle (contributor)\n */\npublic class SittingDuck extends AdvancedRobot {\n  static boolean incrementedBattles = false;\n\n  public void run() {\n   setBodyColor(Color.yellow);\n   setGunColor(Color.yellow);\n\n    int roundCount, battleCount;\n\n    try {\n     BufferedReader reader = null;\n     try {\n       // Read file \"count.dat\" which contains 2 lines, a round count, and a battle count\n        reader = new BufferedReader(new FileReader(getDataFile(\"count.dat\")));\n\n        // Try to get the counts\n        roundCount = Integer.parseInt(reader.readLine());\n       battleCount = Integer.parseInt(reader.readLine());\n\n      } finally {\n       if (reader != null) {\n         reader.close();\n       }\n     }\n   } catch (IOException e) {\n     // Something went wrong reading the file, reset to 0.\n     roundCount = 0;\n     battleCount = 0;\n    } catch (NumberFormatException e) {\n     // Something went wrong converting to ints, reset to 0\n      roundCount = 0;\n     battleCount = 0;\n    }\n\n   // Increment the # of rounds\n    roundCount  ;\n\n   // If we haven\'t incremented # of battles already,\n   // Note: Because robots are only instantiated once per battle, member variables remain valid throughout it.\n   if (!incrementedBattles) {\n      // Increment # of battles\n     battleCount  ;\n      incrementedBattles = true;\n    }\n\n   PrintStream w = null;\n   try {\n     w = new PrintStream(new RobocodeFileOutputStream(getDataFile(\"count.dat\")));\n\n      w.println(roundCount);\n      w.println(battleCount);\n\n     // PrintStreams don\'t throw IOExceptions during prints, they simply set a flag.... so check it here.\n     if (w.checkError()) {\n       out.println(\"I could not write the count!\");\n      }\n   } catch (IOException e) {\n     out.println(\"IOException trying to write: \");\n     e.printStackTrace(out);\n   } finally {\n     if (w != null) {\n        w.close();\n      }\n   }\n   out.println(\"I have been a sitting duck for \"   roundCount   \" rounds, in \"   battleCount   \" battles.\"); \n  }\n}\n\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.RobocodeFileOutputStream;\n\nimport java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\n\n/**\n * SittingDuck - a sample robot by Mathew Nelson.\n * <p/>\n * Along with sitting still doing nothing, this robot demonstrates persistency.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n * @author Andrew Magargle (contributor)\n */\npublic class SittingDuck extends AdvancedRobot {\n static boolean incrementedBattles = false;\n\n  public void run() {\n   setBodyColor(Color.yellow);\n   setGunColor(Color.yellow);\n\n    int roundCount, battleCount;\n\n    try {\n     BufferedReader reader = null;\n     try {\n       // Read file \"count.dat\" which contains 2 lines, a round count, and a battle count\n        reader = new BufferedReader(new FileReader(getDataFile(\"count.dat\")));\n\n        // Try to get the counts\n        roundCount = Integer.parseInt(reader.readLine());\n       battleCount = Integer.parseInt(reader.readLine());\n\n      } finally {\n       if (reader != null) {\n         reader.close();\n       }\n     }\n   } catch (IOException e) {\n     // Something went wrong reading the file, reset to 0.\n     roundCount = 0;\n     battleCount = 0;\n    } catch (NumberFormatException e) {\n     // Something went wrong converting to ints, reset to 0\n      roundCount = 0;\n     battleCount = 0;\n    }\n\n   // Increment the # of rounds\n    roundCount++;\n\n   // If we haven\'t incremented # of battles already,\n   // Note: Because robots are only instantiated once per battle, member variables remain valid throughout it.\n   if (!incrementedBattles) {\n      // Increment # of battles\n     battleCount++;\n      incrementedBattles = true;\n    }\n\n   PrintStream w = null;\n   try {\n     w = new PrintStream(new RobocodeFileOutputStream(getDataFile(\"count.dat\")));\n\n      w.println(roundCount);\n      w.println(battleCount);\n\n     // PrintStreams don\'t throw IOExceptions during prints, they simply set a flag.... so check it here.\n     if (w.checkError()) {\n       out.println(\"I could not write the count!\");\n      }\n   } catch (IOException e) {\n     out.println(\"IOException trying to write: \");\n     e.printStackTrace(out);\n   } finally {\n     if (w != null) {\n        w.close();\n      }\n   }\n   out.println(\"I have been a sitting duck for \" + roundCount + \" rounds, in \" + battleCount + \" battles.\"); \n  }\n}\n',NULL),(11,'User','Package2','SpinBot','Y','C:/robocode/robots/sample/SpinBot.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitRobotEvent;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * SpinBot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a circle, firing hard when an enemy is detected.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class SpinBot extends AdvancedRobot {\n\n  /**\n  * SpinBot\'s run method - Circle\n  */\n public void run() {\n   // Set colors\n   setBodyColor(Color.blue);\n   setGunColor(Color.blue);\n    setRadarColor(Color.black);\n   setScanColor(Color.yellow);\n\n   // Loop forever\n   while (true) {\n      // Tell the game that when we take move,\n      // we\'ll also want to turn right... a lot.\n     setTurnRight(10000);\n      // Limit our speed to 5\n     setMaxVelocity(5);\n      // Start moving (and turning)\n     ahead(10000);\n     // Repeat.\n    }\n }\n\n /**\n  * onScannedRobot: Fire hard!\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(3);\n  }\n\n /**\n  * onHitRobot:  If it\'s our fault, we\'ll stop turning and moving,\n  * so we need to turn again to keep spinning.\n  */\n public void onHitRobot(HitRobotEvent e) {\n   if (e.getBearing() > -10 && e.getBearing() < 10) {\n      fire(3);\n    }\n   if (e.isMyFault()) {\n      turnRight(10);\n    }\n }\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitRobotEvent;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * SpinBot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a circle, firing hard when an enemy is detected.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class SpinBot extends AdvancedRobot {\n\n /**\n  * SpinBot\'s run method - Circle\n  */\n public void run() {\n   // Set colors\n   setBodyColor(Color.blue);\n   setGunColor(Color.blue);\n    setRadarColor(Color.black);\n   setScanColor(Color.yellow);\n\n   // Loop forever\n   while (true) {\n      // Tell the game that when we take move,\n      // we\'ll also want to turn right... a lot.\n     setTurnRight(10000);\n      // Limit our speed to 5\n     setMaxVelocity(5);\n      // Start moving (and turning)\n     ahead(10000);\n     // Repeat.\n    }\n }\n\n /**\n  * onScannedRobot: Fire hard!\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(3);\n  }\n\n /**\n  * onHitRobot:  If it\'s our fault, we\'ll stop turning and moving,\n  * so we need to turn again to keep spinning.\n  */\n public void onHitRobot(HitRobotEvent e) {\n   if (e.getBearing() > -10 && e.getBearing() < 10) {\n      fire(3);\n    }\n   if (e.isMyFault()) {\n      turnRight(10);\n    }\n }\n}\n',NULL),(12,'User','Package2','Target','Y','C:/robocode/robots/sample/Target.java','','Fri Jan 22 17:35:21 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.Condition;\nimport robocode.CustomEvent;\n\nimport java.awt.*;\n\n\n/**\n * Target - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Moves every time energy drops by 20.\n * This Robot demonstrates custom events.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Target extends AdvancedRobot {\n\n  int trigger; // Keeps track of when to move\n\n /**\n  * TrackFire\'s run method\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.white);\n    setGunColor(Color.white);\n   setRadarColor(Color.white);\n\n   // Initially, we\'ll move when life hits 80\n   trigger = 80;\n   // Add a custom event named \"trigger hit\",\n    addCustomEvent(new Condition(\"triggerhit\") {\n      public boolean test() {\n       return (getEnergy() <= trigger);\n      }\n   });\n }\n\n /**\n  * onCustomEvent handler\n   */\n public void onCustomEvent(CustomEvent e) {\n    // If our custom event \"triggerhit\" went off,\n   if (e.getCondition().getName().equals(\"triggerhit\")) {\n      // Adjust the trigger value, or\n     // else the event will fire again and again and again...\n      trigger -= 20;\n      out.println(\"Ouch, down to \"   (int) (getEnergy()   .5)   \" energy.\");\n      // move around a bit.\n     turnLeft(65);\n     ahead(100);\n   }\n }\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.Condition;\nimport robocode.CustomEvent;\n\nimport java.awt.*;\n\n\n/**\n * Target - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Moves every time energy drops by 20.\n * This Robot demonstrates custom events.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Target extends AdvancedRobot {\n\n int trigger; // Keeps track of when to move\n\n /**\n  * TrackFire\'s run method\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.white);\n    setGunColor(Color.white);\n   setRadarColor(Color.white);\n\n   // Initially, we\'ll move when life hits 80\n   trigger = 80;\n   // Add a custom event named \"trigger hit\",\n    addCustomEvent(new Condition(\"triggerhit\") {\n      public boolean test() {\n       return (getEnergy() <= trigger);\n      }\n   });\n }\n\n /**\n  * onCustomEvent handler\n   */\n public void onCustomEvent(CustomEvent e) {\n    // If our custom event \"triggerhit\" went off,\n   if (e.getCondition().getName().equals(\"triggerhit\")) {\n      // Adjust the trigger value, or\n     // else the event will fire again and again and again...\n      trigger -= 20;\n      out.println(\"Ouch, down to \" + (int) (getEnergy() + .5) + \" energy.\");\n      // move around a bit.\n     turnLeft(65);\n     ahead(100);\n   }\n }\n}\n',NULL),(13,'User','Package2','Tracker','Y','C:/robocode/robots/sample/Tracker.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * Tracker - a sample robot by Mathew Nelson.\n * <p/>\n * Locks onto a robot, moves close, fires when close.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Tracker extends Robot {\n int count = 0; // Keeps track of how long we\'ve\n  // been searching for our target\n  double gunTurnAmt; // How much to turn our gun when searching\n String trackName; // Name of the robot we\'re currently tracking\n\n  /**\n  * run:  Tracker\'s main run function\n  */\n public void run() {\n   // Set colors\n   setBodyColor(new Color(128, 128, 50));\n    setGunColor(new Color(50, 50, 20));\n   setRadarColor(new Color(200, 200, 70));\n   setScanColor(Color.white);\n    setBulletColor(Color.blue);\n\n   // Prepare gun\n    trackName = null; // Initialize to not tracking anyone\n    setAdjustGunForRobotTurn(true); // Keep the gun still when we turn\n    gunTurnAmt = 10; // Initialize gunTurn to 10\n\n    // Loop forever\n   while (true) {\n      // turn the Gun (looks for enemy)\n     turnGunRight(gunTurnAmt);\n     // Keep track of how long we\'ve been looking\n     count++;\n      // If we\'ve haven\'t seen our target for 2 turns, look left\n      if (count > 2) {\n        gunTurnAmt = -10;\n     }\n     // If we still haven\'t seen our target for 5 turns, look right\n     if (count > 5) {\n        gunTurnAmt = 10;\n      }\n     // If we *still* haven\'t seen our target after 10 turns, find another target\n     if (count > 11) {\n       trackName = null;\n     }\n   }\n }\n\n /**\n  * onScannedRobot:  Here\'s the good stuff\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n\n   // If we have a target, and this isn\'t it, return immediately\n    // so we can get more ScannedRobotEvents.\n   if (trackName != null && !e.getName().equals(trackName)) {\n      return;\n   }\n\n   // If we don\'t have a target, well, now we do!\n   if (trackName == null) {\n      trackName = e.getName();\n      out.println(\"Tracking \" + trackName);\n   }\n   // This is our target.  Reset count (see the run method)\n    count = 0;\n    // If our target is too far away, turn and move toward it.\n    if (e.getDistance() > 150) {\n      gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n\n     turnGunRight(gunTurnAmt); // Try changing these to setTurnGunRight,\n     turnRight(e.getBearing()); // and see how much Tracker improves...\n      // (you\'ll have to make Tracker an AdvancedRobot)\n      ahead(e.getDistance() - 140);\n     return;\n   }\n\n   // Our target is close.\n   gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n   turnGunRight(gunTurnAmt);\n   fire(3);\n\n    // Our target is too close!  Back up.\n   if (e.getDistance() < 100) {\n      if (e.getBearing() > -90 && e.getBearing() <= 90) {\n       back(40);\n     } else {\n        ahead(40);\n      }\n   }\n   scan();\n }\n\n /**\n  * onHitRobot:  Set him as our new target\n  */\n public void onHitRobot(HitRobotEvent e) {\n   // Only print if he\'s not already our target.\n    if (trackName != null && !trackName.equals(e.getName())) {\n      out.println(\"Tracking \" + e.getName() + \" due to collision\");\n   }\n   // Set the target\n   trackName = e.getName();\n    // Back up a bit.\n   // Note:  We won\'t get scan events while we\'re doing this!\n    // An AdvancedRobot might use setBack(); execute();\n   gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n   turnGunRight(gunTurnAmt);\n   fire(3);\n    back(50);\n }\n\n /**\n  * onWin:  Do a victory dance\n  */\n public void onWin(WinEvent e) {\n   for (int i = 0; i < 50; i++) {\n      turnRight(30);\n      turnLeft(30);\n   }\n }\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * Tracker - a sample robot by Mathew Nelson.\n * <p/>\n * Locks onto a robot, moves close, fires when close.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Tracker extends Robot {\n  int count = 0; // Keeps track of how long we\'ve\n  // been searching for our target\n  double gunTurnAmt; // How much to turn our gun when searching\n String trackName; // Name of the robot we\'re currently tracking\n\n  /**\n  * run:  Tracker\'s main run function\n  */\n public void run() {\n   // Set colors\n   setBodyColor(new Color(128, 128, 50));\n    setGunColor(new Color(50, 50, 20));\n   setRadarColor(new Color(200, 200, 70));\n   setScanColor(Color.white);\n    setBulletColor(Color.blue);\n\n   // Prepare gun\n    trackName = null; // Initialize to not tracking anyone\n    setAdjustGunForRobotTurn(true); // Keep the gun still when we turn\n    gunTurnAmt = 10; // Initialize gunTurn to 10\n\n    // Loop forever\n   while (true) {\n      // turn the Gun (looks for enemy)\n     turnGunRight(gunTurnAmt);\n     // Keep track of how long we\'ve been looking\n     count++;\n      // If we\'ve haven\'t seen our target for 2 turns, look left\n      if (count > 2) {\n        gunTurnAmt = -10;\n     }\n     // If we still haven\'t seen our target for 5 turns, look right\n     if (count > 5) {\n        gunTurnAmt = 10;\n      }\n     // If we *still* haven\'t seen our target after 10 turns, find another target\n     if (count > 11) {\n       trackName = null;\n     }\n   }\n }\n\n /**\n  * onScannedRobot:  Here\'s the good stuff\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n\n   // If we have a target, and this isn\'t it, return immediately\n    // so we can get more ScannedRobotEvents.\n   if (trackName != null && !e.getName().equals(trackName)) {\n      return;\n   }\n\n   // If we don\'t have a target, well, now we do!\n   if (trackName == null) {\n      trackName = e.getName();\n      out.println(\"Tracking \" + trackName);\n   }\n   // This is our target.  Reset count (see the run method)\n    count = 0;\n    // If our target is too far away, turn and move toward it.\n    if (e.getDistance() > 150) {\n      gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n\n     turnGunRight(gunTurnAmt); // Try changing these to setTurnGunRight,\n     turnRight(e.getBearing()); // and see how much Tracker improves...\n      // (you\'ll have to make Tracker an AdvancedRobot)\n      ahead(e.getDistance() - 140);\n     return;\n   }\n\n   // Our target is close.\n   gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n   turnGunRight(gunTurnAmt);\n   fire(3);\n\n    // Our target is too close!  Back up.\n   if (e.getDistance() < 100) {\n      if (e.getBearing() > -90 && e.getBearing() <= 90) {\n       back(40);\n     } else {\n        ahead(40);\n      }\n   }\n   scan();\n }\n\n /**\n  * onHitRobot:  Set him as our new target\n  */\n public void onHitRobot(HitRobotEvent e) {\n   // Only print if he\'s not already our target.\n    if (trackName != null && !trackName.equals(e.getName())) {\n      out.println(\"Tracking \" + e.getName() + \" due to collision\");\n   }\n   // Set the target\n   trackName = e.getName();\n    // Back up a bit.\n   // Note:  We won\'t get scan events while we\'re doing this!\n    // An AdvancedRobot might use setBack(); execute();\n   gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n   turnGunRight(gunTurnAmt);\n   fire(3);\n    back(50);\n }\n\n /**\n  * onWin:  Do a victory dance\n  */\n public void onWin(WinEvent e) {\n   for (int i = 0; i < 50; i++) {\n      turnRight(30);\n      turnLeft(30);\n   }\n }\n}\n',NULL),(14,'User','Package2','TrackFire','Y','C:/robocode/robots/sample/TrackFire.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * TrackFire - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Tracks and fires at the nearest robot it sees.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class TrackFire extends Robot {\n\n /**\n  * TrackFire\'s run method\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.pink);\n   setGunColor(Color.pink);\n    setRadarColor(Color.pink);\n    setScanColor(Color.pink);\n   setBulletColor(Color.pink);\n\n   // Loop forever\n   while (true) {\n      turnGunRight(10); // Scans automatically\n    }\n }\n\n /**\n  * onScannedRobot:  We have a target.  Go get it.\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Calculate exact location of the robot\n    double absoluteBearing = getHeading() + e.getBearing();\n   double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());\n\n    // If it\'s close enough, fire!\n   if (Math.abs(bearingFromGun) <= 3) {\n      turnGunRight(bearingFromGun);\n     // We check gun heat here, because calling fire()\n     // uses a turn, which could cause us to lose track\n      // of the other robot.\n      if (getGunHeat() == 0) {\n        fire(Math.min(3 - Math.abs(bearingFromGun), getEnergy() - .1));\n     }\n   } // otherwise just set the gun to turn.\n    // Note:  This will have no effect until we call scan()\n   else {\n      turnGunRight(bearingFromGun);\n   }\n   // Generates another scan event if we see a robot.\n    // We only need to call this if the gun (and therefore radar)\n   // are not turning.  Otherwise, scan is called automatically.\n   if (bearingFromGun == 0) {\n      scan();\n   }\n }\n\n public void onWin(WinEvent e) {\n   // Victory dance\n    turnRight(36000);\n }\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * TrackFire - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Tracks and fires at the nearest robot it sees.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class TrackFire extends Robot {\n\n  /**\n  * TrackFire\'s run method\n   */\n public void run() {\n   // Set colors\n   setBodyColor(Color.pink);\n   setGunColor(Color.pink);\n    setRadarColor(Color.pink);\n    setScanColor(Color.pink);\n   setBulletColor(Color.pink);\n\n   // Loop forever\n   while (true) {\n      turnGunRight(10); // Scans automatically\n    }\n }\n\n /**\n  * onScannedRobot:  We have a target.  Go get it.\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Calculate exact location of the robot\n    double absoluteBearing = getHeading() + e.getBearing();\n   double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());\n\n    // If it\'s close enough, fire!\n   if (Math.abs(bearingFromGun) <= 3) {\n      turnGunRight(bearingFromGun);\n     // We check gun heat here, because calling fire()\n     // uses a turn, which could cause us to lose track\n      // of the other robot.\n      if (getGunHeat() == 0) {\n        fire(Math.min(3 - Math.abs(bearingFromGun), getEnergy() - .1));\n     }\n   } // otherwise just set the gun to turn.\n    // Note:  This will have no effect until we call scan()\n   else {\n      turnGunRight(bearingFromGun);\n   }\n   // Generates another scan event if we see a robot.\n    // We only need to call this if the gun (and therefore radar)\n   // are not turning.  Otherwise, scan is called automatically.\n   if (bearingFromGun == 0) {\n      scan();\n   }\n }\n\n public void onWin(WinEvent e) {\n   // Victory dance\n    turnRight(36000);\n }\n}        \n',NULL),(15,'User','Package2','VelociRobot','Y','C:/robocode/robots/sample/VelociRobot.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.HitWallEvent;\nimport robocode.RateControlRobot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is a sample of a robot using the RateControlRobot class\n * \n * @author Joshua Galecki (original)\n */\npublic class VelociRobot extends RateControlRobot {\n\n int turnCounter;\n  public void run() {\n\n   turnCounter = 0;\n    setGunRotationRate(15);\n   \n    while (true) {\n      if (turnCounter % 64 == 0) {\n        // Straighten out, if we were hit by a bullet and are turning\n       setTurnRate(0);\n       // Go forward with a velocity of 4\n        setVelocityRate(4);\n     }\n     if (turnCounter % 64 == 32) {\n       // Go backwards, faster\n       setVelocityRate(-6);\n      }\n     turnCounter++;\n      execute();\n    }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   // Turn to confuse the other robot\n    setTurnRate(5);\n }\n \n  public void onHitWall(HitWallEvent e) {\n   // Move away from the wall\n    setVelocityRate(-1 * getVelocityRate());\n  }\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.HitWallEvent;\nimport robocode.RateControlRobot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is a sample of a robot using the RateControlRobot class\n * \n * @author Joshua Galecki (original)\n */\npublic class VelociRobot extends RateControlRobot {\n\n  int turnCounter;\n  public void run() {\n\n   turnCounter = 0;\n    setGunRotationRate(15);\n   \n    while (true) {\n      if (turnCounter % 64 == 0) {\n        // Straighten out, if we were hit by a bullet and are turning\n       setTurnRate(0);\n       // Go forward with a velocity of 4\n        setVelocityRate(4);\n     }\n     if (turnCounter % 64 == 32) {\n       // Go backwards, faster\n       setVelocityRate(-6);\n      }\n     turnCounter++;\n      execute();\n    }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   // Turn to confuse the other robot\n    setTurnRate(5);\n }\n \n  public void onHitWall(HitWallEvent e) {\n   // Move away from the wall\n    setVelocityRate(-1 * getVelocityRate());\n  }\n}\n',NULL),(16,'User','Package3','Walls','Y','C:/robocode/robots/sample/Walls.java','','Mon Jan 25 10:03:39 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * Walls - a sample robot by Mathew Nelson, and maintained by Flemming N. Larsen\n * <p/>\n * Moves around the outer edge with the gun facing in.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Walls extends Robot {\n\n boolean peek; // Don\'t turn if there\'s a robot there\n  double moveAmount; // How much to move\n\n  /**\n  * run: Move around the walls\n  */\n public void run() {\n   // Set colors\n   setBodyColor(Color.black);\n    setGunColor(Color.black);\n   setRadarColor(Color.orange);\n    setBulletColor(Color.cyan);\n   setScanColor(Color.cyan);\n\n   // Initialize moveAmount to the maximum possible for this battlefield.\n    moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());\n   // Initialize peek to false\n   peek = false;\n\n   // turnLeft to face a wall.\n   // getHeading() % 90 means the remainder of\n   // getHeading() divided by 90.\n    turnLeft(getHeading() % 90);\n    ahead(moveAmount);\n    // Turn the gun to turn right 90 degrees.\n   peek = true;\n    turnGunRight(90);\n   turnRight(90);\n\n    while (true) {\n      // Look before we turn when ahead() completes.\n      peek = true;\n      // Move up the wall\n     ahead(moveAmount);\n      // Don\'t look now\n      peek = false;\n     // Turn to the next wall\n      turnRight(90);\n    }\n }\n\n /**\n  * onHitRobot:  Move away a bit.\n   */\n public void onHitRobot(HitRobotEvent e) {\n   // If he\'s in front of us, set back up a bit.\n    if (e.getBearing() > -90 && e.getBearing() < 90) {\n      back(100);\n    } // else he\'s in back of us, so set ahead a bit.\n    else {\n      ahead(100);\n   }\n }\n\n /**\n  * onScannedRobot:  Fire!\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(2);\n    // Note that scan is called automatically when the robot is moving.\n   // By calling it manually here, we make sure we generate another scan event if there\'s a robot on the next\n   // wall, so that we do not start moving up it until it\'s gone.\n   if (peek) {\n     scan();\n   }\n }\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * Walls - a sample robot by Mathew Nelson, and maintained by Flemming N. Larsen\n * <p/>\n * Moves around the outer edge with the gun facing in.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Walls extends Robot {\n\n  boolean peek; // Don\'t turn if there\'s a robot there\n  double moveAmount; // How much to move\n\n  /**\n  * run: Move around the walls\n  */\n public void run() {\n   // Set colors\n   setBodyColor(Color.black);\n    setGunColor(Color.black);\n   setRadarColor(Color.orange);\n    setBulletColor(Color.cyan);\n   setScanColor(Color.cyan);\n\n   // Initialize moveAmount to the maximum possible for this battlefield.\n    moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());\n   // Initialize peek to false\n   peek = false;\n\n   // turnLeft to face a wall.\n   // getHeading() % 90 means the remainder of\n   // getHeading() divided by 90.\n    turnLeft(getHeading() % 90);\n    ahead(moveAmount);\n    // Turn the gun to turn right 90 degrees.\n   peek = true;\n    turnGunRight(90);\n   turnRight(90);\n\n    while (true) {\n      // Look before we turn when ahead() completes.\n      peek = true;\n      // Move up the wall\n     ahead(moveAmount);\n      // Don\'t look now\n      peek = false;\n     // Turn to the next wall\n      turnRight(90);\n    }\n }\n\n /**\n  * onHitRobot:  Move away a bit.\n   */\n public void onHitRobot(HitRobotEvent e) {\n   // If he\'s in front of us, set back up a bit.\n    if (e.getBearing() > -90 && e.getBearing() < 90) {\n      back(100);\n    } // else he\'s in back of us, so set ahead a bit.\n    else {\n      ahead(100);\n   }\n }\n\n /**\n  * onScannedRobot:  Fire!\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(2);\n    // Note that scan is called automatically when the robot is moving.\n   // By calling it manually here, we make sure we generate another scan event if there\'s a robot on the next\n   // wall, so that we do not start moving up it until it\'s gone.\n   if (peek) {\n     scan();\n   }\n }\n}\n',NULL),(17,'User','Package3','Alien','Y','C:/robocode/robots/sampleex/Alien.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n *\n * @author Pavel Savara (original)\n */\npublic class Alien implements IBasicEvents, IBasicRobot, Runnable {\n\n PrintStream out;\n  IStandardRobotPeer peer;\n\n  public Runnable getRobotRunnable() {\n    return this;\n  }\n\n public IBasicEvents getBasicEventListener() {\n   return this;\n  }\n\n public void setPeer(IBasicRobotPeer iRobotPeer) {\n   peer = (IStandardRobotPeer) iRobotPeer;\n }\n\n public void setOut(PrintStream printStream) {\n   out = printStream;\n  }\n\n public void run() {\n   while (true) {\n      peer.move(100); // Move ahead 100\n     peer.turnGun(Math.PI * 2); // Spin gun around\n     peer.move(-100); // Move back 100\n     peer.turnGun(Math.PI * 2); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   peer.setFire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n }\n\n public void onStatus(StatusEvent e) {}\n\n  public void onBulletHit(BulletHitEvent e) {}\n\n  public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n  public void onBulletMissed(BulletMissedEvent e) {}\n\n  public void onDeath(DeathEvent e) {}\n\n  public void onHitRobot(HitRobotEvent e) {}\n\n  public void onHitWall(HitWallEvent e) {}\n\n  public void onRobotDeath(RobotDeathEvent e) {}\n\n  public void onWin(WinEvent e) {}\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n *\n * @author Pavel Savara (original)\n */\npublic class Alien implements IBasicEvents, IBasicRobot, Runnable {\n\n PrintStream out;\n  IStandardRobotPeer peer;\n\n  public Runnable getRobotRunnable() {\n    return this;\n  }\n\n public IBasicEvents getBasicEventListener() {\n   return this;\n  }\n\n public void setPeer(IBasicRobotPeer iRobotPeer) {\n   peer = (IStandardRobotPeer) iRobotPeer;\n }\n\n public void setOut(PrintStream printStream) {\n   out = printStream;\n  }\n\n public void run() {\n   while (true) {\n      peer.move(100); // Move ahead 100\n     peer.turnGun(Math.PI * 2); // Spin gun around\n     peer.move(-100); // Move back 100\n     peer.turnGun(Math.PI * 2); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   peer.setFire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n }\n\n public void onStatus(StatusEvent e) {}\n\n  public void onBulletHit(BulletHitEvent e) {}\n\n  public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n  public void onBulletMissed(BulletMissedEvent e) {}\n\n  public void onDeath(DeathEvent e) {}\n\n  public void onHitRobot(HitRobotEvent e) {}\n\n  public void onHitWall(HitWallEvent e) {}\n\n  public void onRobotDeath(RobotDeathEvent e) {}\n\n  public void onWin(WinEvent e) {}\n}\n',NULL),(18,'User','Package3','AlienComposition','Y','C:/robocode/robots/sampleex/AlienComposition.java','','Fri Dec 18 15:57:54 CST 2015','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n * This composition version is showing possible decomposition of robot, main runnable and event handler to different classes.\n *\n * @author Pavel Savara (original)\n */\npublic class AlienComposition implements IBasicRobot {\n  PrintStream out;\n  IStandardRobotPeer peer;\n  final AlienMain main;\n final AlienEventHandler handler;\n\n  public AlienComposition() {\n   main = new AlienMain();\n   handler = new AlienEventHandler();\n  }\n\n public void setPeer(IBasicRobotPeer iRobotPeer) {\n   peer = (IStandardRobotPeer) iRobotPeer;\n }\n\n public void setOut(PrintStream printStream) {\n   out = printStream;\n  }\n\n public Runnable getRobotRunnable() {\n    return main;\n  }\n\n public IBasicEvents getBasicEventListener() {\n   return handler;\n }\n\n class AlienMain implements Runnable {\n   public void run() {\n     while (true) {\n        peer.move(100); // Move ahead 100\n       peer.turnGun(Math.PI * 2); // Spin gun around\n       peer.move(-100); // Move back 100\n       peer.turnGun(Math.PI * 2); // Spin gun around\n     }\n   }\n }\n\n\n class AlienEventHandler implements IBasicEvents {\n   public void onScannedRobot(ScannedRobotEvent e) {\n     peer.setFire(1);\n    }\n\n   public void onHitByBullet(HitByBulletEvent e) {\n     peer.turnBody(Math.PI / 2   e.getBearingRadians());\n   }\n\n   public void onStatus(StatusEvent e) {}\n\n    public void onBulletHit(BulletHitEvent e) {}\n\n    public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n    public void onBulletMissed(BulletMissedEvent e) {}\n\n    public void onDeath(DeathEvent e) {}\n\n    public void onHitRobot(HitRobotEvent e) {}\n\n    public void onHitWall(HitWallEvent e) {}\n\n    public void onRobotDeath(RobotDeathEvent e) {}\n\n    public void onWin(WinEvent e) {}\n  }\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n * This composition version is showing possible decomposition of robot, main runnable and event handler to different classes.\n *\n * @author Pavel Savara (original)\n */\npublic class AlienComposition implements IBasicRobot {\n  PrintStream out;\n  IStandardRobotPeer peer;\n  final AlienMain main;\n final AlienEventHandler handler;\n\n  public AlienComposition() {\n   main = new AlienMain();\n   handler = new AlienEventHandler();\n  }\n\n public void setPeer(IBasicRobotPeer iRobotPeer) {\n   peer = (IStandardRobotPeer) iRobotPeer;\n }\n\n public void setOut(PrintStream printStream) {\n   out = printStream;\n  }\n\n public Runnable getRobotRunnable() {\n    return main;\n  }\n\n public IBasicEvents getBasicEventListener() {\n   return handler;\n }\n\n class AlienMain implements Runnable {\n   public void run() {\n     while (true) {\n        peer.move(100); // Move ahead 100\n       peer.turnGun(Math.PI * 2); // Spin gun around\n       peer.move(-100); // Move back 100\n       peer.turnGun(Math.PI * 2); // Spin gun around\n     }\n   }\n }\n\n\n class AlienEventHandler implements IBasicEvents {\n   public void onScannedRobot(ScannedRobotEvent e) {\n     peer.setFire(1);\n    }\n\n   public void onHitByBullet(HitByBulletEvent e) {\n     peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n   }\n\n   public void onStatus(StatusEvent e) {}\n\n    public void onBulletHit(BulletHitEvent e) {}\n\n    public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n    public void onBulletMissed(BulletMissedEvent e) {}\n\n    public void onDeath(DeathEvent e) {}\n\n    public void onHitRobot(HitRobotEvent e) {}\n\n    public void onHitWall(HitWallEvent e) {}\n\n    public void onRobotDeath(RobotDeathEvent e) {}\n\n    public void onWin(WinEvent e) {}\n  }\n}\n\n',NULL),(19,'User','Package3','MasterAndSlave','Y','C:/robocode/robots/sampleex/MasterAndSlave.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.robotinterfaces.IAdvancedEvents;\nimport robocode.robotinterfaces.IAdvancedRobot;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IInteractiveEvents;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * @author Pavel Savara (original)\n */\npublic class MasterAndSlave extends MasterBase implements IAdvancedRobot {\n\n /**\n  * This is not showing any aditional qualities over normal MyFirst robot.\n  * But it could, because architecture is no more tied by inheritance from Robot base class.\n  */\n public void run() {\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n\n public IInteractiveEvents getInteractiveEventListener() {\n   return null;\n  }\n}\n\n\n/**\n * Infrastructure base class, for helpers and boring implementation details\n */\nabstract class MasterBase {\n\n  public MasterBase() {\n   helperRobot = new Slave(this);\n  }\n\n private final AdvancedRobot helperRobot;\n\n  public IAdvancedEvents getAdvancedEventListener() {\n   return helperRobot;\n }\n\n public IInteractiveEvents getSystemEventListener() {\n    return helperRobot;\n }\n\n public Runnable getRobotRunnable() {\n    return helperRobot;\n }\n\n public IBasicEvents getBasicEventListener() {\n   return helperRobot;\n }\n\n public void setPeer(IBasicRobotPeer robotPeer) {\n    helperRobot.setPeer(robotPeer);\n }\n\n public void setOut(PrintStream printStream) {\n   helperRobot.setOut(printStream);\n  }\n\n public void turnGunRight(double degrees) {\n    helperRobot.turnGunRight(degrees);\n  }\n\n public void turnLeft(double degrees) {\n    helperRobot.turnLeft(degrees);\n  }\n\n public void ahead(double distance) {\n    helperRobot.ahead(distance);\n  }\n\n public void back(double distance) {\n   helperRobot.back(distance);\n }\n\n public void fire(double power) {\n    helperRobot.fire(power);\n  }\n\n public void onScannedRobot(ScannedRobotEvent e) {}\n\n  public void onHitByBullet(HitByBulletEvent e) {}\n\n  public void run() {}\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.robotinterfaces.IAdvancedEvents;\nimport robocode.robotinterfaces.IAdvancedRobot;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IInteractiveEvents;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * @author Pavel Savara (original)\n */\npublic class MasterAndSlave extends MasterBase implements IAdvancedRobot {\n\n /**\n  * This is not showing any aditional qualities over normal MyFirst robot.\n  * But it could, because architecture is no more tied by inheritance from Robot base class.\n  */\n public void run() {\n   while (true) {\n      ahead(100); // Move ahead 100\n     turnGunRight(360); // Spin gun around\n     back(100); // Move back 100\n     turnGunRight(360); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n\n public IInteractiveEvents getInteractiveEventListener() {\n   return null;\n  }\n}\n\n\n/**\n * Infrastructure base class, for helpers and boring implementation details\n */\nabstract class MasterBase {\n\n  public MasterBase() {\n   helperRobot = new Slave(this);\n  }\n\n private final AdvancedRobot helperRobot;\n\n  public IAdvancedEvents getAdvancedEventListener() {\n   return helperRobot;\n }\n\n public IInteractiveEvents getSystemEventListener() {\n    return helperRobot;\n }\n\n public Runnable getRobotRunnable() {\n    return helperRobot;\n }\n\n public IBasicEvents getBasicEventListener() {\n   return helperRobot;\n }\n\n public void setPeer(IBasicRobotPeer robotPeer) {\n    helperRobot.setPeer(robotPeer);\n }\n\n public void setOut(PrintStream printStream) {\n   helperRobot.setOut(printStream);\n  }\n\n public void turnGunRight(double degrees) {\n    helperRobot.turnGunRight(degrees);\n  }\n\n public void turnLeft(double degrees) {\n    helperRobot.turnLeft(degrees);\n  }\n\n public void ahead(double distance) {\n    helperRobot.ahead(distance);\n  }\n\n public void back(double distance) {\n   helperRobot.back(distance);\n }\n\n public void fire(double power) {\n    helperRobot.fire(power);\n  }\n\n public void onScannedRobot(ScannedRobotEvent e) {}\n\n  public void onHitByBullet(HitByBulletEvent e) {}\n\n  public void run() {}\n}\n',NULL),(20,'User','Package3','ProxyOfGreyEminence','Y','C:/robocode/robots/sampleex/ProxyOfGreyEminence.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is just dummy proxy, it\'s hiding the Eminence and\n * giving it more freedom to inherit from Monk rather than from Robot.\n *\n * @author Pavel Savara (original)\n */\npublic class ProxyOfGreyEminence extends AdvancedRobot {\n private final GreyEminence monk;\n\n  public ProxyOfGreyEminence() {\n    monk = new GreyEminence(this);\n  }\n\n public void onHitByBullet(HitByBulletEvent event) {\n   monk.onHitByBullet(event);\n  }\n\n public void onScannedRobot(ScannedRobotEvent event) {\n   monk.onScannedRobot(event);\n }\n\n public void run() {\n   monk.run();\n }\n}\n\n\n/**\n * The power behind the throne.\n */\nclass GreyEminence extends RegullarMonk {\n  private final ProxyOfGreyEminence proxy;\n\n  public GreyEminence(ProxyOfGreyEminence proxy) {\n    this.proxy = proxy;\n }\n\n /**\n  * This is not showing any aditional qualities over normal MyFirst robot.\n  * But it could, because architecture is no more tied by inheritance from Robot base class.\n  */\n public void run() {\n   while (true) {\n      proxy.ahead(100); // Move ahead 100\n     proxy.turnGunRight(360); // Spin gun around\n     proxy.back(100); // Move back 100\n     proxy.turnGunRight(360); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   proxy.fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   proxy.turnLeft(90 - e.getBearing());\n  }\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is just dummy proxy, it\'s hiding the Eminence and\n * giving it more freedom to inherit from Monk rather than from Robot.\n *\n * @author Pavel Savara (original)\n */\npublic class ProxyOfGreyEminence extends AdvancedRobot {\n private final GreyEminence monk;\n\n  public ProxyOfGreyEminence() {\n    monk = new GreyEminence(this);\n  }\n\n public void onHitByBullet(HitByBulletEvent event) {\n   monk.onHitByBullet(event);\n  }\n\n public void onScannedRobot(ScannedRobotEvent event) {\n   monk.onScannedRobot(event);\n }\n\n public void run() {\n   monk.run();\n }\n}\n\n\n/**\n * The power behind the throne.\n */\nclass GreyEminence extends RegullarMonk {\n  private final ProxyOfGreyEminence proxy;\n\n  public GreyEminence(ProxyOfGreyEminence proxy) {\n    this.proxy = proxy;\n }\n\n /**\n  * This is not showing any aditional qualities over normal MyFirst robot.\n  * But it could, because architecture is no more tied by inheritance from Robot base class.\n  */\n public void run() {\n   while (true) {\n      proxy.ahead(100); // Move ahead 100\n     proxy.turnGunRight(360); // Spin gun around\n     proxy.back(100); // Move back 100\n     proxy.turnGunRight(360); // Spin gun around\n   }\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   proxy.fire(1);\n  }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   proxy.turnLeft(90 - e.getBearing());\n  }\n}\n',NULL),(21,'User','Package3','RegullarMonk','Y','C:/robocode/robots/sampleex/RegullarMonk.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\n/**\n * Monk of a order. Implements anything too boring for Eminence.\n * The infractructure base class.\n *\n * @author Pavel Savara (original)\n */\nabstract class RegullarMonk {}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\n/**\n * Monk of a order. Implements anything too boring for Eminence.\n * The infractructure base class.\n *\n * @author Pavel Savara (original)\n */\nabstract class RegullarMonk {}\n',NULL),(22,'User','Package3','Slave','Y','C:/robocode/robots/sampleex/Slave.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is robot derived from AdvancedRobot.\n * Only reason to use this inheritance and this class is that external robots are unable to call RobotPeer directly.\n *\n * @author Pavel Savara (original)\n */\nclass Slave extends AdvancedRobot {\n  final MasterBase parent;\n\n  public Slave(MasterBase parent) {\n   this.parent = parent;\n }\n\n public void run() {\n   parent.run();\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   parent.onScannedRobot(e);\n }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   parent.onHitByBullet(e);\n  }\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is robot derived from AdvancedRobot.\n * Only reason to use this inheritance and this class is that external robots are unable to call RobotPeer directly.\n *\n * @author Pavel Savara (original)\n */\nclass Slave extends AdvancedRobot {\n  final MasterBase parent;\n\n  public Slave(MasterBase parent) {\n   this.parent = parent;\n }\n\n public void run() {\n   parent.run();\n }\n\n public void onScannedRobot(ScannedRobotEvent e) {\n   parent.onScannedRobot(e);\n }\n\n public void onHitByBullet(HitByBulletEvent e) {\n   parent.onHitByBullet(e);\n  }\n}\n',NULL),(23,'User','Package3','BorderGuard','Y','C:/robocode/robots/samplesentry/BorderGuard','','Mon Jan 25 10:04:31 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage samplesentry;\n\n\nimport robocode.*;\nimport robocode.util.Utils;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\n\n/**\n * BorderGuard - is a sample robot that demonstrates how the BorderSentry interface can be used for\n * creating a robot that guards the border area of the battle field, and which is efficient against\n * robots trying to hide at corners and robots sneaking around near the borders.\n * <p>\n * This robot is somewhat advanced due to:<br>\n * 1) it uses linear targeting for predicting how to hit robots that moves in straight lines.<br>\n * 2) it will only fire at a robot, if it figures out that its bullets will do damage to that\n * particular robot, e.g. when the robots predicted future position will be within the sentry border\n * attack range.<br>\n * 3) it has an efficient scanner that keeps the scan angle as little as possible to get as new\n * scanned data for enemy robots as possible.<br>\n * 4) it picks a target robot to fire at, which is the nearest robot our robot will be able to\n * damage (by predicting its future position using linear targeting).<br>\n * 5) it only moves along the borders of the battle field and constantly changes its direction, so\n * it is not an easy target, and it will try to get as close to its target robot as possible.<br>\n * <p>\n * Lots of improvements can be made to this robot by copying it - making it even stronger. The\n * intention with of this sample robot is to serve as a more advanced example of how a AdvancedRobot\n * can be made, and how it can be structured as most sample robots are far simpler.\n * <p>\n * \n * Credits goes to the hard working Robocoders at the RoboWiki. :-)\n * <p>\n * \n * This robot makes use of the Oldest Scanned melee scanner from the RoboWiki:<br>\n * http://robowiki.net/wiki/Melee_Radar\n * <p>\n * \n * In addition, it makes use of the Exact Non-iterative Solution for Linear Targeting from the\n * RoboWiki:<br>\n * http://robowiki.net/wiki/Linear_Targeting\n * \n * @author Flemming N. Larsen\n * \n * @version 1.0\n * \n * @since 1.9.0.0\n */\npublic class BorderGuard extends AdvancedRobot implements BorderSentry {\n\n  // Constants\n  final double FIREPOWER = 3; // Max. power => violent as this robot can afford it!\n final double HALF_ROBOT_SIZE = 18; // Robot size is 36x36 units, so the half size is 18 units\n\n // Map containing data for all scanned robots.\n  // The key to the map is a robot name and the value is an object containing robot data.\n final Map<String, RobotData> enemyMap;\n\n  // Scanning direction, where the radar turns to the right with positive values, and turns\n // to the left with negative values.\n  double scanDir = 1;\n\n // Oldest scanned robot. Can be null.\n RobotData oldestScanned;\n\n  // Target robot for the gun. Can be null meaning that there is currently no target robot.\n RobotData target;\n\n // Last time when the robot shifted its direction\n long lastDirectionShift;\n\n  // Current direction, where 1 means ahead (forward) and -1 means back\n int direction = 1;\n\n  /**\n  * Constructs this robot.\n  */\n public BorderGuard() {\n    // We initialize a specialized HashMap that uses a linked list for the access order.\n    // This means that the last accessed robot entry is listed first, when we iterate over its\n    // values. This robot always sweep the radar towards the oldest scanned robot.\n    enemyMap = new LinkedHashMap<String, RobotData>(5, 2, true);\n  }\n\n /**\n  * Main method that is called by the game when the robot engage in the next round of a battle.\n   */\n @Override\n public void run() {\n   // Do initialization stuff here before the loop\n   initialize();\n\n   // Loop forever. If the robot does not take action, the game will disable our robot!\n    while (true) {\n      // Handle a single turn...\n\n      // Handle the radar that scans enemy robots\n     handleRadar();\n      // Handle the gun by turning it and fire at our target\n      handleGun();\n      // Move the robot around on the battlefield\n     moveRobot();\n\n      // Scan for other robots. Note that this method will execute all pending commands for\n     // the next turn. Hence, scan() ends the turn for our robot.\n      scan();\n   }\n }\n\n /**\n  * This method is called by the game when your robot sees another robot, i.e. when the robot\'s\n  * radar scan \"hits\" another robot.\n  * \n  * @param scannedRobotEvent\n  *            is a ScannedRobotEvent event.\n  */\n @Override\n public void onScannedRobot(ScannedRobotEvent scannedRobotEvent) {\n   // Check that the scanned robot is not a sentry robot\n   if (!scannedRobotEvent.isSentryRobot()) {\n     // The scanned robot is not a sentry robot...\n\n     // Update the enemy map\n     updateEnemyMap(scannedRobotEvent);\n\n      // Update the scan direction\n      updateScanDirection(scannedRobotEvent);\n\n     // Update enemy target positions\n      updateEnemyTargetPositions();\n   }\n }\n\n /**\n  * This method is called by the game when another robot dies.\n  * \n  * @param robotDeathEvent\n  *            is the RobotDeathEvent that occurs, when another robot dies, which contains data\n   *            for the robot that died.\n   */\n @Override\n public void onRobotDeath(RobotDeathEvent robotDeathEvent) {\n   // Gets the name of the robot that died\n   final String deadRobotName = robotDeathEvent.getName();\n\n   // Remove the robot data for the robot that died from the enemy map\n   enemyMap.remove(deadRobotName);\n\n   // Remove the data entry for the oldest scanned robot, if we have such an entry\n   if (oldestScanned != null ','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage samplesentry;\n\n\nimport robocode.*;\nimport robocode.util.Utils;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\n\n/**\n * BorderGuard - is a sample robot that demonstrates how the BorderSentry interface can be used for\n * creating a robot that guards the border area of the battle field, and which is efficient against\n * robots trying to hide at corners and robots sneaking around near the borders.\n * <p>\n * This robot is somewhat advanced due to:<br>\n * 1) it uses linear targeting for predicting how to hit robots that moves in straight lines.<br>\n * 2) it will only fire at a robot, if it figures out that its bullets will do damage to that\n * particular robot, e.g. when the robots predicted future position will be within the sentry border\n * attack range.<br>\n * 3) it has an efficient scanner that keeps the scan angle as little as possible to get as new\n * scanned data for enemy robots as possible.<br>\n * 4) it picks a target robot to fire at, which is the nearest robot our robot will be able to\n * damage (by predicting its future position using linear targeting).<br>\n * 5) it only moves along the borders of the battle field and constantly changes its direction, so\n * it is not an easy target, and it will try to get as close to its target robot as possible.<br>\n * <p>\n * Lots of improvements can be made to this robot by copying it - making it even stronger. The\n * intention with of this sample robot is to serve as a more advanced example of how a AdvancedRobot\n * can be made, and how it can be structured as most sample robots are far simpler.\n * <p>\n * \n * Credits goes to the hard working Robocoders at the RoboWiki. :-)\n * <p>\n * \n * This robot makes use of the Oldest Scanned melee scanner from the RoboWiki:<br>\n * http://robowiki.net/wiki/Melee_Radar\n * <p>\n * \n * In addition, it makes use of the Exact Non-iterative Solution for Linear Targeting from the\n * RoboWiki:<br>\n * http://robowiki.net/wiki/Linear_Targeting\n * \n * @author Flemming N. Larsen\n * \n * @version 1.0\n * \n * @since 1.9.0.0\n */\npublic class BorderGuard extends AdvancedRobot implements BorderSentry {\n\n  // Constants\n  final double FIREPOWER = 3; // Max. power => violent as this robot can afford it!\n final double HALF_ROBOT_SIZE = 18; // Robot size is 36x36 units, so the half size is 18 units\n\n // Map containing data for all scanned robots.\n  // The key to the map is a robot name and the value is an object containing robot data.\n final Map<String, RobotData> enemyMap;\n\n  // Scanning direction, where the radar turns to the right with positive values, and turns\n // to the left with negative values.\n  double scanDir = 1;\n\n // Oldest scanned robot. Can be null.\n RobotData oldestScanned;\n\n  // Target robot for the gun. Can be null meaning that there is currently no target robot.\n RobotData target;\n\n // Last time when the robot shifted its direction\n long lastDirectionShift;\n\n  // Current direction, where 1 means ahead (forward) and -1 means back\n int direction = 1;\n\n  /**\n  * Constructs this robot.\n  */\n public BorderGuard() {\n    // We initialize a specialized HashMap that uses a linked list for the access order.\n    // This means that the last accessed robot entry is listed first, when we iterate over its\n    // values. This robot always sweep the radar towards the oldest scanned robot.\n    enemyMap = new LinkedHashMap<String, RobotData>(5, 2, true);\n  }\n\n /**\n  * Main method that is called by the game when the robot engage in the next round of a battle.\n   */\n @Override\n public void run() {\n   // Do initialization stuff here before the loop\n   initialize();\n\n   // Loop forever. If the robot does not take action, the game will disable our robot!\n    while (true) {\n      // Handle a single turn...\n\n      // Handle the radar that scans enemy robots\n     handleRadar();\n      // Handle the gun by turning it and fire at our target\n      handleGun();\n      // Move the robot around on the battlefield\n     moveRobot();\n\n      // Scan for other robots. Note that this method will execute all pending commands for\n     // the next turn. Hence, scan() ends the turn for our robot.\n      scan();\n   }\n }\n\n /**\n  * This method is called by the game when your robot sees another robot, i.e. when the robot\'s\n  * radar scan \"hits\" another robot.\n  * \n  * @param scannedRobotEvent\n  *            is a ScannedRobotEvent event.\n  */\n @Override\n public void onScannedRobot(ScannedRobotEvent scannedRobotEvent) {\n   // Check that the scanned robot is not a sentry robot\n   if (!scannedRobotEvent.isSentryRobot()) {\n     // The scanned robot is not a sentry robot...\n\n     // Update the enemy map\n     updateEnemyMap(scannedRobotEvent);\n\n      // Update the scan direction\n      updateScanDirection(scannedRobotEvent);\n\n     // Update enemy target positions\n      updateEnemyTargetPositions();\n   }\n }\n\n /**\n  * This method is called by the game when another robot dies.\n  * \n  * @param robotDeathEvent\n  *            is the RobotDeathEvent that occurs, when another robot dies, which contains data\n   *            for the robot that died.\n   */\n @Override\n public void onRobotDeath(RobotDeathEvent robotDeathEvent) {\n   // Gets the name of the robot that died\n   final String deadRobotName = robotDeathEvent.getName();\n\n   // Remove the robot data for the robot that died from the enemy map\n   enemyMap.remove(deadRobotName);\n\n   // Remove the data entry for the oldest scanned robot, if we have such an entry\n   if (oldestScanned != null ',NULL),(24,'User','Package3','MyFirstDroid','Y','C:/robocode/robots/sampleteam/MyFirstDroid.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleteam;\n\n\nimport robocode.Droid;\nimport robocode.MessageEvent;\nimport robocode.TeamRobot;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\n\n/**\n * SimpleDroid - a sample robot by Mathew Nelson.\n * <p/>\n * Follows orders of team leader.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class MyFirstDroid extends TeamRobot implements Droid {\n\n /**\n  * run:  Droid\'s default behavior\n   */\n public void run() {\n   out.println(\"MyFirstDroid ready.\");\n }\n\n /**\n  * onMessageReceived:  What to do when our leader sends a message\n  */\n public void onMessageReceived(MessageEvent e) {\n   // Fire at a point\n    if (e.getMessage() instanceof Point) {\n      Point p = (Point) e.getMessage();\n     // Calculate x and y to target\n      double dx = p.getX() - this.getX();\n     double dy = p.getY() - this.getY();\n     // Calculate angle to target\n      double theta = Math.toDegrees(Math.atan2(dx, dy));\n\n      // Turn gun to target\n     turnGunRight(normalRelativeAngleDegrees(theta - getGunHeading()));\n      // Fire hard!\n     fire(3);\n    } // Set our colors\n   else if (e.getMessage() instanceof RobotColors) {\n     RobotColors c = (RobotColors) e.getMessage();\n\n     setBodyColor(c.bodyColor);\n      setGunColor(c.gunColor);\n      setRadarColor(c.radarColor);\n      setScanColor(c.scanColor);\n      setBulletColor(c.bulletColor);\n    }\n }\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleteam;\n\n\nimport robocode.Droid;\nimport robocode.MessageEvent;\nimport robocode.TeamRobot;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\n\n/**\n * SimpleDroid - a sample robot by Mathew Nelson.\n * <p/>\n * Follows orders of team leader.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class MyFirstDroid extends TeamRobot implements Droid {\n\n  /**\n  * run:  Droid\'s default behavior\n   */\n public void run() {\n   out.println(\"MyFirstDroid ready.\");\n }\n\n /**\n  * onMessageReceived:  What to do when our leader sends a message\n  */\n public void onMessageReceived(MessageEvent e) {\n   // Fire at a point\n    if (e.getMessage() instanceof Point) {\n      Point p = (Point) e.getMessage();\n     // Calculate x and y to target\n      double dx = p.getX() - this.getX();\n     double dy = p.getY() - this.getY();\n     // Calculate angle to target\n      double theta = Math.toDegrees(Math.atan2(dx, dy));\n\n      // Turn gun to target\n     turnGunRight(normalRelativeAngleDegrees(theta - getGunHeading()));\n      // Fire hard!\n     fire(3);\n    } // Set our colors\n   else if (e.getMessage() instanceof RobotColors) {\n     RobotColors c = (RobotColors) e.getMessage();\n\n     setBodyColor(c.bodyColor);\n      setGunColor(c.gunColor);\n      setRadarColor(c.radarColor);\n      setScanColor(c.scanColor);\n      setBulletColor(c.bulletColor);\n    }\n }\n}\n',NULL),(25,'User','Package3','MyFirstLeader','Y','C:/robocode/robots/sampleteam/MyFirstTeam.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleteam;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.TeamRobot;\n\nimport java.awt.*;\nimport java.io.IOException;\n\n\n/**\n * MyFirstLeader - a sample team robot by Mathew Nelson.\n * <p/>\n * Looks around for enemies, and orders teammates to fire\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class MyFirstLeader extends TeamRobot {\n\n  /**\n  * run:  Leader\'s default behavior\n  */\n public void run() {\n   // Prepare RobotColors object\n   RobotColors c = new RobotColors();\n\n    c.bodyColor = Color.red;\n    c.gunColor = Color.red;\n   c.radarColor = Color.red;\n   c.scanColor = Color.yellow;\n   c.bulletColor = Color.yellow;\n\n   // Set the color of this robot containing the RobotColors\n   setBodyColor(c.bodyColor);\n    setGunColor(c.gunColor);\n    setRadarColor(c.radarColor);\n    setScanColor(c.scanColor);\n    setBulletColor(c.bulletColor);\n    try {\n     // Send RobotColors object to our entire team\n     broadcastMessage(c);\n    } catch (IOException ignored) {}\n    // Normal behavior\n    while (true) {\n      setTurnRadarRight(10000);\n     ahead(100);\n     back(100);\n    }\n }\n\n /**\n  * onScannedRobot:  What to do when you see another robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Don\'t fire on teammates\n   if (isTeammate(e.getName())) {\n      return;\n   }\n   // Calculate enemy bearing\n    double enemyBearing = this.getHeading() + e.getBearing();\n   // Calculate enemy\'s position\n    double enemyX = getX() + e.getDistance() * Math.sin(Math.toRadians(enemyBearing));\n    double enemyY = getY() + e.getDistance() * Math.cos(Math.toRadians(enemyBearing));\n\n    try {\n     // Send enemy position to teammates\n     broadcastMessage(new Point(enemyX, enemyY));\n    } catch (IOException ex) {\n      out.println(\"Unable to send order: \");\n      ex.printStackTrace(out);\n    }\n }\n\n /**\n  * onHitByBullet:  Turn perpendicular to bullet path\n   */\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleteam;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.TeamRobot;\n\nimport java.awt.*;\nimport java.io.IOException;\n\n\n/**\n * MyFirstLeader - a sample team robot by Mathew Nelson.\n * <p/>\n * Looks around for enemies, and orders teammates to fire\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class MyFirstLeader extends TeamRobot {\n\n /**\n  * run:  Leader\'s default behavior\n  */\n public void run() {\n   // Prepare RobotColors object\n   RobotColors c = new RobotColors();\n\n    c.bodyColor = Color.red;\n    c.gunColor = Color.red;\n   c.radarColor = Color.red;\n   c.scanColor = Color.yellow;\n   c.bulletColor = Color.yellow;\n\n   // Set the color of this robot containing the RobotColors\n   setBodyColor(c.bodyColor);\n    setGunColor(c.gunColor);\n    setRadarColor(c.radarColor);\n    setScanColor(c.scanColor);\n    setBulletColor(c.bulletColor);\n    try {\n     // Send RobotColors object to our entire team\n     broadcastMessage(c);\n    } catch (IOException ignored) {}\n    // Normal behavior\n    while (true) {\n      setTurnRadarRight(10000);\n     ahead(100);\n     back(100);\n    }\n }\n\n /**\n  * onScannedRobot:  What to do when you see another robot\n  */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Don\'t fire on teammates\n   if (isTeammate(e.getName())) {\n      return;\n   }\n   // Calculate enemy bearing\n    double enemyBearing = this.getHeading() + e.getBearing();\n   // Calculate enemy\'s position\n    double enemyX = getX() + e.getDistance() * Math.sin(Math.toRadians(enemyBearing));\n    double enemyY = getY() + e.getDistance() * Math.cos(Math.toRadians(enemyBearing));\n\n    try {\n     // Send enemy position to teammates\n     broadcastMessage(new Point(enemyX, enemyY));\n    } catch (IOException ex) {\n      out.println(\"Unable to send order: \");\n      ex.printStackTrace(out);\n    }\n }\n\n /**\n  * onHitByBullet:  Turn perpendicular to bullet path\n   */\n public void onHitByBullet(HitByBulletEvent e) {\n   turnLeft(90 - e.getBearing());\n  }\n}\n',NULL),(71,'User','Package3','Test0109','Y','C:/robocode/robots/sample/Test0109.java','Fri Sep 01 11:55:28 CDT 2017','Fri Sep 01 11:55:36 CDT 2017','package sample;\n\nimport robocode.*;\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n//import java.awt.Color;\n\n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n\n/**\n * Test0109- a robot by User\n */\npublic class Test0109 extends Robot{\n  /**\n  * run: Test0109default behavior\n   */\n public void run() {\n // Initialization of the robot should be put here\n\n // After trying out your robot, try uncommenting the import at the top,\n // and the next line:\n\n // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n\n // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n\n /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n \n  /**\n  * onHitWall: What to do when you hit a wall\n   */\n public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(1120);\n } \n}\n    ','package sample;\n\nimport robocode.*;\nimport robocode.HitByBulletEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n//import java.awt.Color;\n\n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n\n/**\n * Test0109- a robot by User\n */\npublic class Test0109 extends Robot{\n  /**\n  * run: Test0109default behavior\n   */\n public void run() {\n // Initialization of the robot should be put here\n\n // After trying out your robot, try uncommenting the import at the top,\n // and the next line:\n\n // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n\n // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n\n /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n \n  /**\n  * onHitWall: What to do when you hit a wall\n   */\n public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(1120);\n } \n}\n    ',NULL),(72,'User','Package3','test1234','Y','C:/robocode/robots/sample/test1234.java','Fri Sep 01 13:22:11 CDT 2017',NULL,'package sample;\nimport robocode.*;\n//import java.awt.Color;\n            \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* test1234- a robot by User\n */\npublic class test1234 extends Robot{ /**\n  * run: test1234default behavior   */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n','package sample;\nimport robocode.*;\n//import java.awt.Color;\n            \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* test1234- a robot by User\n */\npublic class test1234 extends Robot{ /**\n  * run: test1234default behavior   */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n',NULL),(73,'User','Package3','new','Y','/Users/neethuantony/git/CCRoboGroupD/RobocodeV1/robocode/robots/sample/new.java','Wed Dec 13 17:52:52 CST 2017',NULL,'package sample;\nimport robocode.*;\n//import java.awt.Color;\n            \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* new- a robot by User\n */\npublic class new extends Robot{ /**\n  * run: newdefault behavior  */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n',NULL,NULL),(74,'User1','Package3','newRobot','Y','/Users/neethuantony/git/CCRoboGroupD/RobocodeV1/robocode/robots/sample/newRobot.java','Wed Dec 13 17:53:43 CST 2017',NULL,'package sample;\nimport robocode.*;\n//import java.awt.Color;\n            \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* newRobot- a robot by User1\n */\npublic class newRobot extends Robot{  /**\n  * run: newRobotdefault behavior   */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n',NULL,'org1'),(83,'User1','Package3','777','N','/Users/neethuantony/git/CCRoboGroupD/RobocodeV1/robocode/robots/sample/777.java','Wed Dec 13 20:25:07 CST 2017',NULL,'package sample;\nimport robocode.*;\n//import java.awt.Color;\n            \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* 777- a robot by User1\n */\npublic class 777 extends Robot{  /**\n  * run: 777default behavior  */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n',NULL,'org1'),(84,'Arun','Package1','Arun Robot','N','/Users/neethuantony/git/CCRoboGroupD/RobocodeV1/robocode/robots/Package1/Arun Robot.java','Fri Dec 15 11:15:58 CST 2017',NULL,'package Package1;\nimport robocode.*;\n//import java.awt.Color;\n           \n// API help: http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html\n                              \n/**\n* Arun Robot- a robot by Arun\n */\npublic class Arun Robot extends Robot{ /**\n  * run: Arun Robotdefault behavior   */\n public void run() {\n // Initialization of the robot should be put here\n                       \n  // After trying out your robot, try uncommenting the import at the top\n  // and the next line:\n           \n  // setColors(Color.red,Color.blue,Color.green); // body,gun,radar\n               \n  // Robot main loop\n    while(true) {\n     // Replace the next 4 lines with any behavior you would like\n      ahead(100);\n     turnGunRight(360);\n      back(100);\n      turnGunRight(360);\n    }\n }\n /**\n  * onScannedRobot: What to do when you see another robot\n   */\n public void onScannedRobot(ScannedRobotEvent e) {\n   // Replace the next line with any behavior you would like\n   fire(1);\n  }\n           \n  /**\n  * onHitByBullet: What to do when you\'re hit by a bullet\n  */\n public void onHitByBullet(HitByBulletEvent e) {\n   // Replace the next line with any behavior you would like\n   back(10);\n }\n         \n  /**  * onHitWall: What to do when you hit a wall\n   */ public void onHitWall(HitWallEvent e) {\n   // Replace the next line with any behavior you would like\n   back(20);\n } \n} \n',NULL,'org1');
/*!40000 ALTER TABLE `robot` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `totalstat`
--

DROP TABLE IF EXISTS `totalstat`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `totalstat` (
  `Rank` int(11) DEFAULT NULL,
  `RobotName` varchar(30) DEFAULT NULL,
  `TotalScore` int(11) DEFAULT NULL,
  `PercentofTotal` int(11) DEFAULT NULL,
  `1sts` int(11) DEFAULT NULL,
  `2nds` int(11) DEFAULT NULL,
  `3rds` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `totalstat`
--

LOCK TABLES `totalstat` WRITE;
/*!40000 ALTER TABLE `totalstat` DISABLE KEYS */;
/*!40000 ALTER TABLE `totalstat` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `trial`
--

DROP TABLE IF EXISTS `trial`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `trial` (
  `robotname` varchar(255) DEFAULT NULL,
  `robotcode` text
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `trial`
--

LOCK TABLES `trial` WRITE;
/*!40000 ALTER TABLE `trial` DISABLE KEYS */;
/*!40000 ALTER TABLE `trial` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `userpackages`
--

DROP TABLE IF EXISTS `userpackages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `userpackages` (
  `userid` varchar(50) NOT NULL,
  `packagename` varchar(45) NOT NULL,
  PRIMARY KEY (`userid`,`packagename`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `userpackages`
--

LOCK TABLES `userpackages` WRITE;
/*!40000 ALTER TABLE `userpackages` DISABLE KEYS */;
INSERT INTO `userpackages` VALUES ('1','demoPacakge'),('admin','demo'),('admin','demo1'),('admin','Package2'),('john','ArunPackage'),('newuser','newuserdemo'),('User','Package1'),('User','Package2'),('User','Package3'),('User1','Package1'),('User1','Package2'),('User1','Package3'),('User1','Package4');
/*!40000 ALTER TABLE `userpackages` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-12-15 15:30:37
