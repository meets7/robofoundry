-- MySQL dump 10.13  Distrib 5.7.20, for Linux (x86_64)
--
-- Host: localhost    Database: robocode
-- ------------------------------------------------------
-- Server version	5.7.20-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `battlestat`
--

DROP TABLE IF EXISTS `battlestat`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `battlestat` (
  `Rank` int(11) DEFAULT NULL,
  `RobotName` varchar(30) DEFAULT NULL,
  `TotalScore` int(11) DEFAULT NULL,
  `PercentofTotal` int(11) DEFAULT NULL,
  `Survival` int(11) DEFAULT NULL,
  `SurvivalBonus` int(11) DEFAULT NULL,
  `BulletDmg` int(11) DEFAULT NULL,
  `BulletBonus` int(11) DEFAULT NULL,
  `RamDmg2` int(11) DEFAULT NULL,
  `RamBonus` int(11) DEFAULT NULL,
  `1sts` int(11) DEFAULT NULL,
  `2nds` int(11) DEFAULT NULL,
  `3rds` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `battlestat`
--

LOCK TABLES `battlestat` WRITE;
/*!40000 ALTER TABLE `battlestat` DISABLE KEYS */;
/*!40000 ALTER TABLE `battlestat` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `relationship`
--

DROP TABLE IF EXISTS `relationship`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `relationship` (
  `relationshipid` int(11) NOT NULL AUTO_INCREMENT,
  `robotid` varchar(45) NOT NULL,
  `userid` varchar(45) NOT NULL,
  PRIMARY KEY (`relationshipid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `relationship`
--

LOCK TABLES `relationship` WRITE;
/*!40000 ALTER TABLE `relationship` DISABLE KEYS */;
/*!40000 ALTER TABLE `relationship` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `robot`
--

DROP TABLE IF EXISTS `robot`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `robot` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `userID` varchar(80) DEFAULT NULL,
  `packageID` varchar(80) DEFAULT NULL,
  `robotID` varchar(80) DEFAULT NULL,
  `dataaccess` varchar(4) DEFAULT NULL,
  `filepath` longtext,
  `CreatedDate` varchar(200) DEFAULT NULL,
  `UpdatedDate` varchar(200) DEFAULT NULL,
  `RobotCode` longtext,
  `file` longblob,
  `org` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=88 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `robot`
--

LOCK TABLES `robot` WRITE;
/*!40000 ALTER TABLE `robot` DISABLE KEYS */;
INSERT INTO `robot` VALUES (1,'mark','Package1','Crazy','Y','C:/robocode/robots/sample/Crazy.java','Mon Jan 25 10:27:35 CST 2016','Fri Sep 23 17:06:41 CDT 2016','  /**Hi\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n\r\n\r\n\r\n				\r\n    \r\n				\r\n    \r\n				\r\n    \r\n \r\n     \r\n    \r\n   \r\n \r\n \r\n','  /**Hi\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n\r\n\r\n\r\n				\r\n    \r\n				\r\n    \r\n				\r\n    \r\n \r\n     \r\n    \r\n   \r\n \r\n \r\n','org1'),(2,'mark','Package1','Corners','Y','C:/robocode/robots/sample/Corners.java','Mon Jan 25 10:27:35 CST 2016','Mon Feb 01 14:44:42 CST 2016','/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.DeathEvent;\r\nimport robocode.Robot;\r\nimport robocode.ScannedRobotEvent;\r\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Corners - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves to a corner, then swings the gun back and forth.\r\n * If it dies, it tries a new corner in the next round.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Corners extends Robot {\r\n	int others; // Number of other robots in the game\r\n	static int corner = 0; // Which corner we are currently using\r\n	// static so that it keeps it between rounds.\r\n	boolean stopWhenSeeRobot = false; // See goCorner()\r\n\r\n	/**\r\n	 * run:  Corners\' main run function.\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(Color.red);\r\n		setGunColor(Color.black);\r\n		setRadarColor(Color.yellow);\r\n		setBulletColor(Color.green);\r\n		setScanColor(Color.green);\r\n\r\n		// Save # of other bots\r\n		others = getOthers();\r\n\r\n		// Move to a corner\r\n		goCorner();\r\n\r\n		// Initialize gun turn speed to 3\r\n		int gunIncrement = 3;\r\n\r\n		// Spin gun back and forth\r\n		while (true) {\r\n			for (int i = 0; i < 30; i++) {\r\n				turnGunLeft(gunIncrement);\r\n			}\r\n			gunIncrement *= -1;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * goCorner:  A very inefficient way to get to a corner.  Can you do better?\r\n	 */\r\n	public void goCorner() {\r\n		// We don\'t want to stop when we\'re just turning...\r\n		stopWhenSeeRobot = false;\r\n		// turn to face the wall to the \"right\" of our desired corner.\r\n		turnRight(normalRelativeAngleDegrees(corner - getHeading()));\r\n		// Ok, now we don\'t want to crash into any robot in our way...\r\n		stopWhenSeeRobot = true;\r\n		// Move to that wall\r\n		ahead(5000);\r\n		// Turn to face the corner\r\n		turnLeft(90);\r\n		// Move to the corner\r\n		ahead(5000);\r\n		// Turn gun to starting point\r\n		turnGunLeft(90);\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Stop and fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		// Should we stop, or just fire?\r\n		if (stopWhenSeeRobot) {\r\n			// Stop everything!  You can safely call stop multiple times.\r\n			stop();\r\n			// Call our custom firing method\r\n			smartFire(e.getDistance());\r\n			// Look for another robot.\r\n			// NOTE:  If you call scan() inside onScannedRobot, and it sees a robot,\r\n			// the game will interrupt the event handler and start it over\r\n			scan();\r\n			// We won\'t get here if we saw another robot.\r\n			// Okay, we didn\'t see another robot... start moving or turning again.\r\n			resume();\r\n		} else {\r\n			smartFire(e.getDistance());\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * smartFire:  Custom fire method that determines firepower based on distance.\r\n	 *\r\n	 * @param robotDistance the distance to the robot to fire at\r\n	 */\r\n	public void smartFire(double robotDistance) {\r\n		if (robotDistance > 200 || getEnergy() < 15) {\r\n			fire(1);\r\n		} else if (robotDistance > 50) {\r\n			fire(2);\r\n		} else {\r\n			fire(3);\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onDeath:  We died.  Decide whether to try a different corner next game.\r\n	 */\r\n	public void onDeath(DeathEvent e) {\r\n		// Well, others should never be 0, but better safe than sorry.\r\n		if (others == 0) {\r\n			return;\r\n		}\r\n\r\n		// If 75% of the robots are still alive when we die, we\'ll switch corners.\r\n		if ((others - getOthers()) / (double) others < .75) {\r\n			corner += 90;\r\n			if (corner == 270) {\r\n				corner = -90;\r\n			}\r\n			out.println(\"I died and did poorly... switching corner to \" + corner);\r\n		} else {\r\n			out.println(\"I died but did well.  I will still use corner \" + corner);\r\n		}\r\n	}\r\n}\r\n\r\n\r\n \r\n    \r\n\r\n \r\n    \r\n','/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n    boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back \r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.*;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Crazy - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves around in a crazy pattern.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Crazy extends AdvancedRobot {\r\n	boolean movingForward;\r\n\r\n	/**\r\n	 * run: Crazy\'s main run function\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(new Color(0, 200, 0));\r\n		setGunColor(new Color(0, 150, 50));\r\n		setRadarColor(new Color(0, 100, 100));\r\n		setBulletColor(new Color(255, 255, 100));\r\n		setScanColor(new Color(255, 200, 200));\r\n\r\n		// Loop forever\r\n		while (true) {\r\n			// Tell the game we will want to move ahead 40000 -- some large number\r\n			setAhead(40000);\r\n			movingForward = true;\r\n			// Tell the game we will want to turn right 90\r\n			setTurnRight(90);\r\n			// At this point, we have indicated to the game that *when we do something*,\r\n			// we will want to move ahead and turn right.  That\'s what \"set\" means.\r\n			// It is important to realize we have not done anything yet!\r\n			// In order to actually move, we\'ll want to call a method that\r\n			// takes real time, such as waitFor.\r\n			// waitFor actually starts the action -- we start moving and turning.\r\n			// It will not return until we have finished turning.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// Note:  We are still moving ahead now, but the turn is complete.\r\n			// Now we\'ll turn the other way...\r\n			setTurnLeft(180);\r\n			// ... and wait for the turn to finish ...\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// ... then the other way ...\r\n			setTurnRight(180);\r\n			// .. and wait for that turn to finish.\r\n			waitFor(new TurnCompleteCondition(this));\r\n			// then back to the top to do it all again\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onHitWall:  Handle collision with wall.\r\n	 */\r\n	public void onHitWall(HitWallEvent e) {\r\n		// Bounce off!\r\n		reverseDirection();\r\n	}\r\n\r\n	/**\r\n	 * reverseDirection:  Switch from ahead to back & vice versa\r\n	 */\r\n	public void reverseDirection() {\r\n		if (movingForward) {\r\n			setBack(40000);\r\n			movingForward = false;\r\n		} else {\r\n			setAhead(40000);\r\n			movingForward = true;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		fire(1);\r\n	}\r\n\r\n	/**\r\n	 * onHitRobot:  Back up!\r\n	 */\r\n	public void onHitRobot(HitRobotEvent e) {\r\n		// If we\'re moving the other robot, reverse!\r\n		if (e.isMyFault()) {\r\n			reverseDirection();\r\n		}\r\n	}\r\n}\r\n/**\r\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://robocode.sourceforge.net/license/epl-v10.html\r\n */\r\npackage sample;\r\n\r\n\r\nimport robocode.DeathEvent;\r\nimport robocode.Robot;\r\nimport robocode.ScannedRobotEvent;\r\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\r\n\r\nimport java.awt.*;\r\n\r\n\r\n/**\r\n * Corners - a sample robot by Mathew Nelson.\r\n * \r\n * This robot moves to a corner, then swings the gun back and forth.\r\n * If it dies, it tries a new corner in the next round.\r\n *\r\n * @author Mathew A. Nelson (original)\r\n * @author Flemming N. Larsen (contributor)\r\n */\r\npublic class Corners extends Robot {\r\n	int others; // Number of other robots in the game\r\n	static int corner = 0; // Which corner we are currently using\r\n	// static so that it keeps it between rounds.\r\n	boolean stopWhenSeeRobot = false; // See goCorner()\r\n\r\n	/**\r\n	 * run:  Corners\' main run function.\r\n	 */\r\n	public void run() {\r\n		// Set colors\r\n		setBodyColor(Color.red);\r\n		setGunColor(Color.black);\r\n		setRadarColor(Color.yellow);\r\n		setBulletColor(Color.green);\r\n		setScanColor(Color.green);\r\n\r\n		// Save # of other bots\r\n		others = getOthers();\r\n\r\n		// Move to a corner\r\n		goCorner();\r\n\r\n		// Initialize gun turn speed to 3\r\n		int gunIncrement = 3;\r\n\r\n		// Spin gun back and forth\r\n		while (true) {\r\n			for (int i = 0; i < 30; i++) {\r\n				turnGunLeft(gunIncrement);\r\n			}\r\n			gunIncrement *= -1;\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * goCorner:  A very inefficient way to get to a corner.  Can you do better?\r\n	 */\r\n	public void goCorner() {\r\n		// We don\'t want to stop when we\'re just turning...\r\n		stopWhenSeeRobot = false;\r\n		// turn to face the wall to the \"right\" of our desired corner.\r\n		turnRight(normalRelativeAngleDegrees(corner - getHeading()));\r\n		// Ok, now we don\'t want to crash into any robot in our way...\r\n		stopWhenSeeRobot = true;\r\n		// Move to that wall\r\n		ahead(5000);\r\n		// Turn to face the corner\r\n		turnLeft(90);\r\n		// Move to the corner\r\n		ahead(5000);\r\n		// Turn gun to starting point\r\n		turnGunLeft(90);\r\n	}\r\n\r\n	/**\r\n	 * onScannedRobot:  Stop and fire!\r\n	 */\r\n	public void onScannedRobot(ScannedRobotEvent e) {\r\n		// Should we stop, or just fire?\r\n		if (stopWhenSeeRobot) {\r\n			// Stop everything!  You can safely call stop multiple times.\r\n			stop();\r\n			// Call our custom firing method\r\n			smartFire(e.getDistance());\r\n			// Look for another robot.\r\n			// NOTE:  If you call scan() inside onScannedRobot, and it sees a robot,\r\n			// the game will interrupt the event handler and start it over\r\n			scan();\r\n			// We won\'t get here if we saw another robot.\r\n			// Okay, we didn\'t see another robot... start moving or turning again.\r\n			resume();\r\n		} else {\r\n			smartFire(e.getDistance());\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * smartFire:  Custom fire method that determines firepower based on distance.\r\n	 *\r\n	 * @param robotDistance the distance to the robot to fire at\r\n	 */\r\n	public void smartFire(double robotDistance) {\r\n		if (robotDistance > 200 || getEnergy() < 15) {\r\n			fire(1);\r\n		} else if (robotDistance > 50) {\r\n			fire(2);\r\n		} else {\r\n			fire(3);\r\n		}\r\n	}\r\n\r\n	/**\r\n	 * onDeath:  We died.  Decide whether to try a different corner next game.\r\n	 */\r\n	public void onDeath(DeathEvent e) {\r\n		// Well, others should never be 0, but better safe than sorry.\r\n		if (others == 0) {\r\n			return;\r\n		}\r\n\r\n		// If 75% of the robots are still alive when we die, we\'ll switch corners.\r\n		if ((others - getOthers()) / (double) others < .75) {\r\n			corner += 90;\r\n			if (corner == 270) {\r\n				corner = -90;\r\n			}\r\n			out.println(\"I died and did poorly... switching corner to \" + corner);\r\n		} else {\r\n			out.println(\"I died but did well.  I will still use corner \" + corner);\r\n		}\r\n	}\r\n}\r\n\r\n\r\n \r\n    \r\n\r\n \r\n    \r\n','org2'),(9,'marsh','Package1','RamFire','Y','C:/robocode/robots/sample/RamFire.java','','Tue Jan 26 11:34:09 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * RamFire - a sample robot by Mathew Nelson.\n * <p/>\n * Drives at robots trying to ram them.\n * Fires when it hits them.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class RamFire extends Robot {\n	int turnDirection = 1; // Clockwise or counterclockwise\n\n	/**\n	 * run: Spin around looking for a target\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.lightGray);\n		setGunColor(Color.gray);\n		setRadarColor(Color.darkGray);\n\n		while (true) {\n			turnRight(5 * turnDirection);\n		}\n	}\n\n	/**\n	 * onScannedRobot:  We have a target.  Go get it.\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n\n		if (e.getBearing() >= 0) {\n			turnDirection = 1;\n		} else {\n			turnDirection = -1;\n		}\n\n		turnRight(e.getBearing());\n		ahead(e.getDistance());\n		scan(); // Might want to move ahead again!\n	}\n\n	/**\n	 * onHitRobot:  Turn to face robot, fire hard, and ram him again!\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		if (e.getBearing() >= 0) {\n			turnDirection = 1;\n		} else {\n			turnDirection = -1;\n		}\n		turnRight(e.getBearing());\n\n		// Determine a shot that won\'t kill the robot...\n		// We want to ram him instead for bonus points\n		if (e.getEnergy() > 16) {\n			fire(3);\n		} else if (e.getEnergy() > 10) {\n			fire(2);\n		} else if (e.getEnergy() > 4) {\n			fire(1);\n		} else if (e.getEnergy() > 2) {\n			fire(.5);\n		} else if (e.getEnergy() > .4) {\n			fire(.1);\n		}\n		ahead(40); // Ram him again!\n	}\n}\n\n\n\n\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * RamFire - a sample robot by Mathew Nelson.\n * <p/>\n * Drives at robots trying to ram them.\n * Fires when it hits them.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class RamFire extends Robot {\n	int turnDirection = 1; // Clockwise or counterclockwise\n\n	/**\n	 * run: Spin around looking for a target\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.lightGray);\n		setGunColor(Color.gray);\n		setRadarColor(Color.darkGray);\n\n		while (true) {\n			turnRight(5 * turnDirection);\n		}\n	}\n\n	/**\n	 * onScannedRobot:  We have a target.  Go get it.\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n\n		if (e.getBearing() >= 0) {\n			turnDirection = 1;\n		} else {\n			turnDirection = -1;\n		}\n\n		turnRight(e.getBearing());\n		ahead(e.getDistance() + 5);\n		scan(); // Might want to move ahead again!\n	}\n\n	/**\n	 * onHitRobot:  Turn to face robot, fire hard, and ram him again!\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		if (e.getBearing() >= 0) {\n			turnDirection = 1;\n		} else {\n			turnDirection = -1;\n		}\n		turnRight(e.getBearing());\n\n		// Determine a shot that won\'t kill the robot...\n		// We want to ram him instead for bonus points\n		if (e.getEnergy() > 16) {\n			fire(3);\n		} else if (e.getEnergy() > 10) {\n			fire(2);\n		} else if (e.getEnergy() > 4) {\n			fire(1);\n		} else if (e.getEnergy() > 2) {\n			fire(.5);\n		} else if (e.getEnergy() > .4) {\n			fire(.1);\n		}\n		ahead(40); // Ram him again!\n	}\n}\n',NULL),(10,'mellisa','Package1','SittingDuck','Y','C:/robocode/robots/sample/SittingDuck.java','','Fri Jan 22 17:45:16 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.RobocodeFileOutputStream;\n\nimport java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\n\n/**\n * SittingDuck - a sample robot by Mathew Nelson.\n * <p/>\n * Along with sitting still doing nothing, this robot demonstrates persistency.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n * @author Andrew Magargle (contributor)\n */\npublic class SittingDuck extends AdvancedRobot {\n	static boolean incrementedBattles = false;\n\n	public void run() {\n		setBodyColor(Color.yellow);\n		setGunColor(Color.yellow);\n\n		int roundCount, battleCount;\n\n		try {\n			BufferedReader reader = null;\n			try {\n				// Read file \"count.dat\" which contains 2 lines, a round count, and a battle count\n				reader = new BufferedReader(new FileReader(getDataFile(\"count.dat\")));\n\n				// Try to get the counts\n				roundCount = Integer.parseInt(reader.readLine());\n				battleCount = Integer.parseInt(reader.readLine());\n\n			} finally {\n				if (reader != null) {\n					reader.close();\n				}\n			}\n		} catch (IOException e) {\n			// Something went wrong reading the file, reset to 0.\n			roundCount = 0;\n			battleCount = 0;\n		} catch (NumberFormatException e) {\n			// Something went wrong converting to ints, reset to 0\n			roundCount = 0;\n			battleCount = 0;\n		}\n\n		// Increment the # of rounds\n		roundCount  ;\n\n		// If we haven\'t incremented # of battles already,\n		// Note: Because robots are only instantiated once per battle, member variables remain valid throughout it.\n		if (!incrementedBattles) {\n			// Increment # of battles\n			battleCount  ;\n			incrementedBattles = true;\n		}\n\n		PrintStream w = null;\n		try {\n			w = new PrintStream(new RobocodeFileOutputStream(getDataFile(\"count.dat\")));\n\n			w.println(roundCount);\n			w.println(battleCount);\n\n			// PrintStreams don\'t throw IOExceptions during prints, they simply set a flag.... so check it here.\n			if (w.checkError()) {\n				out.println(\"I could not write the count!\");\n			}\n		} catch (IOException e) {\n			out.println(\"IOException trying to write: \");\n			e.printStackTrace(out);\n		} finally {\n			if (w != null) {\n				w.close();\n			}\n		}\n		out.println(\"I have been a sitting duck for \"   roundCount   \" rounds, in \"   battleCount   \" battles.\"); \n	}\n}\n\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.RobocodeFileOutputStream;\n\nimport java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\n\n/**\n * SittingDuck - a sample robot by Mathew Nelson.\n * <p/>\n * Along with sitting still doing nothing, this robot demonstrates persistency.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n * @author Andrew Magargle (contributor)\n */\npublic class SittingDuck extends AdvancedRobot {\n	static boolean incrementedBattles = false;\n\n	public void run() {\n		setBodyColor(Color.yellow);\n		setGunColor(Color.yellow);\n\n		int roundCount, battleCount;\n\n		try {\n			BufferedReader reader = null;\n			try {\n				// Read file \"count.dat\" which contains 2 lines, a round count, and a battle count\n				reader = new BufferedReader(new FileReader(getDataFile(\"count.dat\")));\n\n				// Try to get the counts\n				roundCount = Integer.parseInt(reader.readLine());\n				battleCount = Integer.parseInt(reader.readLine());\n\n			} finally {\n				if (reader != null) {\n					reader.close();\n				}\n			}\n		} catch (IOException e) {\n			// Something went wrong reading the file, reset to 0.\n			roundCount = 0;\n			battleCount = 0;\n		} catch (NumberFormatException e) {\n			// Something went wrong converting to ints, reset to 0\n			roundCount = 0;\n			battleCount = 0;\n		}\n\n		// Increment the # of rounds\n		roundCount++;\n\n		// If we haven\'t incremented # of battles already,\n		// Note: Because robots are only instantiated once per battle, member variables remain valid throughout it.\n		if (!incrementedBattles) {\n			// Increment # of battles\n			battleCount++;\n			incrementedBattles = true;\n		}\n\n		PrintStream w = null;\n		try {\n			w = new PrintStream(new RobocodeFileOutputStream(getDataFile(\"count.dat\")));\n\n			w.println(roundCount);\n			w.println(battleCount);\n\n			// PrintStreams don\'t throw IOExceptions during prints, they simply set a flag.... so check it here.\n			if (w.checkError()) {\n				out.println(\"I could not write the count!\");\n			}\n		} catch (IOException e) {\n			out.println(\"IOException trying to write: \");\n			e.printStackTrace(out);\n		} finally {\n			if (w != null) {\n				w.close();\n			}\n		}\n		out.println(\"I have been a sitting duck for \" + roundCount + \" rounds, in \" + battleCount + \" battles.\"); \n	}\n}\n',NULL),(11,'mark','Package2','SpinBot','Y','C:/robocode/robots/sample/SpinBot.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitRobotEvent;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * SpinBot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a circle, firing hard when an enemy is detected.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class SpinBot extends AdvancedRobot {\n\n	/**\n	 * SpinBot\'s run method - Circle\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.blue);\n		setGunColor(Color.blue);\n		setRadarColor(Color.black);\n		setScanColor(Color.yellow);\n\n		// Loop forever\n		while (true) {\n			// Tell the game that when we take move,\n			// we\'ll also want to turn right... a lot.\n			setTurnRight(10000);\n			// Limit our speed to 5\n			setMaxVelocity(5);\n			// Start moving (and turning)\n			ahead(10000);\n			// Repeat.\n		}\n	}\n\n	/**\n	 * onScannedRobot: Fire hard!\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(3);\n	}\n\n	/**\n	 * onHitRobot:  If it\'s our fault, we\'ll stop turning and moving,\n	 * so we need to turn again to keep spinning.\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		if (e.getBearing() > -10 && e.getBearing() < 10) {\n			fire(3);\n		}\n		if (e.isMyFault()) {\n			turnRight(10);\n		}\n	}\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitRobotEvent;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * SpinBot - a sample robot by Mathew Nelson.\n * <p/>\n * Moves in a circle, firing hard when an enemy is detected.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class SpinBot extends AdvancedRobot {\n\n	/**\n	 * SpinBot\'s run method - Circle\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.blue);\n		setGunColor(Color.blue);\n		setRadarColor(Color.black);\n		setScanColor(Color.yellow);\n\n		// Loop forever\n		while (true) {\n			// Tell the game that when we take move,\n			// we\'ll also want to turn right... a lot.\n			setTurnRight(10000);\n			// Limit our speed to 5\n			setMaxVelocity(5);\n			// Start moving (and turning)\n			ahead(10000);\n			// Repeat.\n		}\n	}\n\n	/**\n	 * onScannedRobot: Fire hard!\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(3);\n	}\n\n	/**\n	 * onHitRobot:  If it\'s our fault, we\'ll stop turning and moving,\n	 * so we need to turn again to keep spinning.\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		if (e.getBearing() > -10 && e.getBearing() < 10) {\n			fire(3);\n		}\n		if (e.isMyFault()) {\n			turnRight(10);\n		}\n	}\n}\n',NULL),(12,'marsh','Package2','Target','Y','C:/robocode/robots/sample/Target.java','','Fri Jan 22 17:35:21 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.Condition;\nimport robocode.CustomEvent;\n\nimport java.awt.*;\n\n\n/**\n * Target - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Moves every time energy drops by 20.\n * This Robot demonstrates custom events.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Target extends AdvancedRobot {\n\n	int trigger; // Keeps track of when to move\n\n	/**\n	 * TrackFire\'s run method\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.white);\n		setGunColor(Color.white);\n		setRadarColor(Color.white);\n\n		// Initially, we\'ll move when life hits 80\n		trigger = 80;\n		// Add a custom event named \"trigger hit\",\n		addCustomEvent(new Condition(\"triggerhit\") {\n			public boolean test() {\n				return (getEnergy() <= trigger);\n			}\n		});\n	}\n\n	/**\n	 * onCustomEvent handler\n	 */\n	public void onCustomEvent(CustomEvent e) {\n		// If our custom event \"triggerhit\" went off,\n		if (e.getCondition().getName().equals(\"triggerhit\")) {\n			// Adjust the trigger value, or\n			// else the event will fire again and again and again...\n			trigger -= 20;\n			out.println(\"Ouch, down to \"   (int) (getEnergy()   .5)   \" energy.\");\n			// move around a bit.\n			turnLeft(65);\n			ahead(100);\n		}\n	}\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.Condition;\nimport robocode.CustomEvent;\n\nimport java.awt.*;\n\n\n/**\n * Target - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Moves every time energy drops by 20.\n * This Robot demonstrates custom events.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Target extends AdvancedRobot {\n\n	int trigger; // Keeps track of when to move\n\n	/**\n	 * TrackFire\'s run method\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.white);\n		setGunColor(Color.white);\n		setRadarColor(Color.white);\n\n		// Initially, we\'ll move when life hits 80\n		trigger = 80;\n		// Add a custom event named \"trigger hit\",\n		addCustomEvent(new Condition(\"triggerhit\") {\n			public boolean test() {\n				return (getEnergy() <= trigger);\n			}\n		});\n	}\n\n	/**\n	 * onCustomEvent handler\n	 */\n	public void onCustomEvent(CustomEvent e) {\n		// If our custom event \"triggerhit\" went off,\n		if (e.getCondition().getName().equals(\"triggerhit\")) {\n			// Adjust the trigger value, or\n			// else the event will fire again and again and again...\n			trigger -= 20;\n			out.println(\"Ouch, down to \" + (int) (getEnergy() + .5) + \" energy.\");\n			// move around a bit.\n			turnLeft(65);\n			ahead(100);\n		}\n	}\n}\n',NULL),(13,'dani','Package2','Tracker','Y','C:/robocode/robots/sample/Tracker.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * Tracker - a sample robot by Mathew Nelson.\n * <p/>\n * Locks onto a robot, moves close, fires when close.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Tracker extends Robot {\n	int count = 0; // Keeps track of how long we\'ve\n	// been searching for our target\n	double gunTurnAmt; // How much to turn our gun when searching\n	String trackName; // Name of the robot we\'re currently tracking\n\n	/**\n	 * run:  Tracker\'s main run function\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(new Color(128, 128, 50));\n		setGunColor(new Color(50, 50, 20));\n		setRadarColor(new Color(200, 200, 70));\n		setScanColor(Color.white);\n		setBulletColor(Color.blue);\n\n		// Prepare gun\n		trackName = null; // Initialize to not tracking anyone\n		setAdjustGunForRobotTurn(true); // Keep the gun still when we turn\n		gunTurnAmt = 10; // Initialize gunTurn to 10\n\n		// Loop forever\n		while (true) {\n			// turn the Gun (looks for enemy)\n			turnGunRight(gunTurnAmt);\n			// Keep track of how long we\'ve been looking\n			count++;\n			// If we\'ve haven\'t seen our target for 2 turns, look left\n			if (count > 2) {\n				gunTurnAmt = -10;\n			}\n			// If we still haven\'t seen our target for 5 turns, look right\n			if (count > 5) {\n				gunTurnAmt = 10;\n			}\n			// If we *still* haven\'t seen our target after 10 turns, find another target\n			if (count > 11) {\n				trackName = null;\n			}\n		}\n	}\n\n	/**\n	 * onScannedRobot:  Here\'s the good stuff\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n\n		// If we have a target, and this isn\'t it, return immediately\n		// so we can get more ScannedRobotEvents.\n		if (trackName != null && !e.getName().equals(trackName)) {\n			return;\n		}\n\n		// If we don\'t have a target, well, now we do!\n		if (trackName == null) {\n			trackName = e.getName();\n			out.println(\"Tracking \" + trackName);\n		}\n		// This is our target.  Reset count (see the run method)\n		count = 0;\n		// If our target is too far away, turn and move toward it.\n		if (e.getDistance() > 150) {\n			gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n\n			turnGunRight(gunTurnAmt); // Try changing these to setTurnGunRight,\n			turnRight(e.getBearing()); // and see how much Tracker improves...\n			// (you\'ll have to make Tracker an AdvancedRobot)\n			ahead(e.getDistance() - 140);\n			return;\n		}\n\n		// Our target is close.\n		gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n		turnGunRight(gunTurnAmt);\n		fire(3);\n\n		// Our target is too close!  Back up.\n		if (e.getDistance() < 100) {\n			if (e.getBearing() > -90 && e.getBearing() <= 90) {\n				back(40);\n			} else {\n				ahead(40);\n			}\n		}\n		scan();\n	}\n\n	/**\n	 * onHitRobot:  Set him as our new target\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		// Only print if he\'s not already our target.\n		if (trackName != null && !trackName.equals(e.getName())) {\n			out.println(\"Tracking \" + e.getName() + \" due to collision\");\n		}\n		// Set the target\n		trackName = e.getName();\n		// Back up a bit.\n		// Note:  We won\'t get scan events while we\'re doing this!\n		// An AdvancedRobot might use setBack(); execute();\n		gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n		turnGunRight(gunTurnAmt);\n		fire(3);\n		back(50);\n	}\n\n	/**\n	 * onWin:  Do a victory dance\n	 */\n	public void onWin(WinEvent e) {\n		for (int i = 0; i < 50; i++) {\n			turnRight(30);\n			turnLeft(30);\n		}\n	}\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * Tracker - a sample robot by Mathew Nelson.\n * <p/>\n * Locks onto a robot, moves close, fires when close.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Tracker extends Robot {\n	int count = 0; // Keeps track of how long we\'ve\n	// been searching for our target\n	double gunTurnAmt; // How much to turn our gun when searching\n	String trackName; // Name of the robot we\'re currently tracking\n\n	/**\n	 * run:  Tracker\'s main run function\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(new Color(128, 128, 50));\n		setGunColor(new Color(50, 50, 20));\n		setRadarColor(new Color(200, 200, 70));\n		setScanColor(Color.white);\n		setBulletColor(Color.blue);\n\n		// Prepare gun\n		trackName = null; // Initialize to not tracking anyone\n		setAdjustGunForRobotTurn(true); // Keep the gun still when we turn\n		gunTurnAmt = 10; // Initialize gunTurn to 10\n\n		// Loop forever\n		while (true) {\n			// turn the Gun (looks for enemy)\n			turnGunRight(gunTurnAmt);\n			// Keep track of how long we\'ve been looking\n			count++;\n			// If we\'ve haven\'t seen our target for 2 turns, look left\n			if (count > 2) {\n				gunTurnAmt = -10;\n			}\n			// If we still haven\'t seen our target for 5 turns, look right\n			if (count > 5) {\n				gunTurnAmt = 10;\n			}\n			// If we *still* haven\'t seen our target after 10 turns, find another target\n			if (count > 11) {\n				trackName = null;\n			}\n		}\n	}\n\n	/**\n	 * onScannedRobot:  Here\'s the good stuff\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n\n		// If we have a target, and this isn\'t it, return immediately\n		// so we can get more ScannedRobotEvents.\n		if (trackName != null && !e.getName().equals(trackName)) {\n			return;\n		}\n\n		// If we don\'t have a target, well, now we do!\n		if (trackName == null) {\n			trackName = e.getName();\n			out.println(\"Tracking \" + trackName);\n		}\n		// This is our target.  Reset count (see the run method)\n		count = 0;\n		// If our target is too far away, turn and move toward it.\n		if (e.getDistance() > 150) {\n			gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n\n			turnGunRight(gunTurnAmt); // Try changing these to setTurnGunRight,\n			turnRight(e.getBearing()); // and see how much Tracker improves...\n			// (you\'ll have to make Tracker an AdvancedRobot)\n			ahead(e.getDistance() - 140);\n			return;\n		}\n\n		// Our target is close.\n		gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n		turnGunRight(gunTurnAmt);\n		fire(3);\n\n		// Our target is too close!  Back up.\n		if (e.getDistance() < 100) {\n			if (e.getBearing() > -90 && e.getBearing() <= 90) {\n				back(40);\n			} else {\n				ahead(40);\n			}\n		}\n		scan();\n	}\n\n	/**\n	 * onHitRobot:  Set him as our new target\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		// Only print if he\'s not already our target.\n		if (trackName != null && !trackName.equals(e.getName())) {\n			out.println(\"Tracking \" + e.getName() + \" due to collision\");\n		}\n		// Set the target\n		trackName = e.getName();\n		// Back up a bit.\n		// Note:  We won\'t get scan events while we\'re doing this!\n		// An AdvancedRobot might use setBack(); execute();\n		gunTurnAmt = normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getRadarHeading()));\n		turnGunRight(gunTurnAmt);\n		fire(3);\n		back(50);\n	}\n\n	/**\n	 * onWin:  Do a victory dance\n	 */\n	public void onWin(WinEvent e) {\n		for (int i = 0; i < 50; i++) {\n			turnRight(30);\n			turnLeft(30);\n		}\n	}\n}\n',NULL),(14,'monica','Package2','TrackFire','Y','C:/robocode/robots/sample/TrackFire.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * TrackFire - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Tracks and fires at the nearest robot it sees.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class TrackFire extends Robot {\n\n	/**\n	 * TrackFire\'s run method\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.pink);\n		setGunColor(Color.pink);\n		setRadarColor(Color.pink);\n		setScanColor(Color.pink);\n		setBulletColor(Color.pink);\n\n		// Loop forever\n		while (true) {\n			turnGunRight(10); // Scans automatically\n		}\n	}\n\n	/**\n	 * onScannedRobot:  We have a target.  Go get it.\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		// Calculate exact location of the robot\n		double absoluteBearing = getHeading() + e.getBearing();\n		double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());\n\n		// If it\'s close enough, fire!\n		if (Math.abs(bearingFromGun) <= 3) {\n			turnGunRight(bearingFromGun);\n			// We check gun heat here, because calling fire()\n			// uses a turn, which could cause us to lose track\n			// of the other robot.\n			if (getGunHeat() == 0) {\n				fire(Math.min(3 - Math.abs(bearingFromGun), getEnergy() - .1));\n			}\n		} // otherwise just set the gun to turn.\n		// Note:  This will have no effect until we call scan()\n		else {\n			turnGunRight(bearingFromGun);\n		}\n		// Generates another scan event if we see a robot.\n		// We only need to call this if the gun (and therefore radar)\n		// are not turning.  Otherwise, scan is called automatically.\n		if (bearingFromGun == 0) {\n			scan();\n		}\n	}\n\n	public void onWin(WinEvent e) {\n		// Victory dance\n		turnRight(36000);\n	}\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\nimport robocode.WinEvent;\nimport static robocode.util.Utils.normalRelativeAngleDegrees;\n\nimport java.awt.*;\n\n\n/**\n * TrackFire - a sample robot by Mathew Nelson.\n * <p/>\n * Sits still. Tracks and fires at the nearest robot it sees.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class TrackFire extends Robot {\n\n	/**\n	 * TrackFire\'s run method\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.pink);\n		setGunColor(Color.pink);\n		setRadarColor(Color.pink);\n		setScanColor(Color.pink);\n		setBulletColor(Color.pink);\n\n		// Loop forever\n		while (true) {\n			turnGunRight(10); // Scans automatically\n		}\n	}\n\n	/**\n	 * onScannedRobot:  We have a target.  Go get it.\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		// Calculate exact location of the robot\n		double absoluteBearing = getHeading() + e.getBearing();\n		double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());\n\n		// If it\'s close enough, fire!\n		if (Math.abs(bearingFromGun) <= 3) {\n			turnGunRight(bearingFromGun);\n			// We check gun heat here, because calling fire()\n			// uses a turn, which could cause us to lose track\n			// of the other robot.\n			if (getGunHeat() == 0) {\n				fire(Math.min(3 - Math.abs(bearingFromGun), getEnergy() - .1));\n			}\n		} // otherwise just set the gun to turn.\n		// Note:  This will have no effect until we call scan()\n		else {\n			turnGunRight(bearingFromGun);\n		}\n		// Generates another scan event if we see a robot.\n		// We only need to call this if the gun (and therefore radar)\n		// are not turning.  Otherwise, scan is called automatically.\n		if (bearingFromGun == 0) {\n			scan();\n		}\n	}\n\n	public void onWin(WinEvent e) {\n		// Victory dance\n		turnRight(36000);\n	}\n}				\n',NULL),(15,'david','Package3','VelociRobot','Y','C:/robocode/robots/sample/VelociRobot.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.HitWallEvent;\nimport robocode.RateControlRobot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is a sample of a robot using the RateControlRobot class\n * \n * @author Joshua Galecki (original)\n */\npublic class VelociRobot extends RateControlRobot {\n\n	int turnCounter;\n	public void run() {\n\n		turnCounter = 0;\n		setGunRotationRate(15);\n		\n		while (true) {\n			if (turnCounter % 64 == 0) {\n				// Straighten out, if we were hit by a bullet and are turning\n				setTurnRate(0);\n				// Go forward with a velocity of 4\n				setVelocityRate(4);\n			}\n			if (turnCounter % 64 == 32) {\n				// Go backwards, faster\n				setVelocityRate(-6);\n			}\n			turnCounter++;\n			execute();\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		// Turn to confuse the other robot\n		setTurnRate(5);\n	}\n	\n	public void onHitWall(HitWallEvent e) {\n		// Move away from the wall\n		setVelocityRate(-1 * getVelocityRate());\n	}\n}','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitByBulletEvent;\nimport robocode.HitWallEvent;\nimport robocode.RateControlRobot;\nimport robocode.ScannedRobotEvent;\n\n\n/**\n * This is a sample of a robot using the RateControlRobot class\n * \n * @author Joshua Galecki (original)\n */\npublic class VelociRobot extends RateControlRobot {\n\n	int turnCounter;\n	public void run() {\n\n		turnCounter = 0;\n		setGunRotationRate(15);\n		\n		while (true) {\n			if (turnCounter % 64 == 0) {\n				// Straighten out, if we were hit by a bullet and are turning\n				setTurnRate(0);\n				// Go forward with a velocity of 4\n				setVelocityRate(4);\n			}\n			if (turnCounter % 64 == 32) {\n				// Go backwards, faster\n				setVelocityRate(-6);\n			}\n			turnCounter++;\n			execute();\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		// Turn to confuse the other robot\n		setTurnRate(5);\n	}\n	\n	public void onHitWall(HitWallEvent e) {\n		// Move away from the wall\n		setVelocityRate(-1 * getVelocityRate());\n	}\n}\n',NULL),(16,'dani','Package3','Walls','Y','C:/robocode/robots/sample/Walls.java','','Mon Jan 25 10:03:39 CST 2016','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * Walls - a sample robot by Mathew Nelson, and maintained by Flemming N. Larsen\n * <p/>\n * Moves around the outer edge with the gun facing in.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Walls extends Robot {\n\n	boolean peek; // Don\'t turn if there\'s a robot there\n	double moveAmount; // How much to move\n\n	/**\n	 * run: Move around the walls\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.black);\n		setGunColor(Color.black);\n		setRadarColor(Color.orange);\n		setBulletColor(Color.cyan);\n		setScanColor(Color.cyan);\n\n		// Initialize moveAmount to the maximum possible for this battlefield.\n		moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());\n		// Initialize peek to false\n		peek = false;\n\n		// turnLeft to face a wall.\n		// getHeading() % 90 means the remainder of\n		// getHeading() divided by 90.\n		turnLeft(getHeading() % 90);\n		ahead(moveAmount);\n		// Turn the gun to turn right 90 degrees.\n		peek = true;\n		turnGunRight(90);\n		turnRight(90);\n\n		while (true) {\n			// Look before we turn when ahead() completes.\n			peek = true;\n			// Move up the wall\n			ahead(moveAmount);\n			// Don\'t look now\n			peek = false;\n			// Turn to the next wall\n			turnRight(90);\n		}\n	}\n\n	/**\n	 * onHitRobot:  Move away a bit.\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		// If he\'s in front of us, set back up a bit.\n		if (e.getBearing() > -90 && e.getBearing() < 90) {\n			back(100);\n		} // else he\'s in back of us, so set ahead a bit.\n		else {\n			ahead(100);\n		}\n	}\n\n	/**\n	 * onScannedRobot:  Fire!\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(2);\n		// Note that scan is called automatically when the robot is moving.\n		// By calling it manually here, we make sure we generate another scan event if there\'s a robot on the next\n		// wall, so that we do not start moving up it until it\'s gone.\n		if (peek) {\n			scan();\n		}\n	}\n}\n','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sample;\n\n\nimport robocode.HitRobotEvent;\nimport robocode.Robot;\nimport robocode.ScannedRobotEvent;\n\nimport java.awt.*;\n\n\n/**\n * Walls - a sample robot by Mathew Nelson, and maintained by Flemming N. Larsen\n * <p/>\n * Moves around the outer edge with the gun facing in.\n *\n * @author Mathew A. Nelson (original)\n * @author Flemming N. Larsen (contributor)\n */\npublic class Walls extends Robot {\n\n	boolean peek; // Don\'t turn if there\'s a robot there\n	double moveAmount; // How much to move\n\n	/**\n	 * run: Move around the walls\n	 */\n	public void run() {\n		// Set colors\n		setBodyColor(Color.black);\n		setGunColor(Color.black);\n		setRadarColor(Color.orange);\n		setBulletColor(Color.cyan);\n		setScanColor(Color.cyan);\n\n		// Initialize moveAmount to the maximum possible for this battlefield.\n		moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());\n		// Initialize peek to false\n		peek = false;\n\n		// turnLeft to face a wall.\n		// getHeading() % 90 means the remainder of\n		// getHeading() divided by 90.\n		turnLeft(getHeading() % 90);\n		ahead(moveAmount);\n		// Turn the gun to turn right 90 degrees.\n		peek = true;\n		turnGunRight(90);\n		turnRight(90);\n\n		while (true) {\n			// Look before we turn when ahead() completes.\n			peek = true;\n			// Move up the wall\n			ahead(moveAmount);\n			// Don\'t look now\n			peek = false;\n			// Turn to the next wall\n			turnRight(90);\n		}\n	}\n\n	/**\n	 * onHitRobot:  Move away a bit.\n	 */\n	public void onHitRobot(HitRobotEvent e) {\n		// If he\'s in front of us, set back up a bit.\n		if (e.getBearing() > -90 && e.getBearing() < 90) {\n			back(100);\n		} // else he\'s in back of us, so set ahead a bit.\n		else {\n			ahead(100);\n		}\n	}\n\n	/**\n	 * onScannedRobot:  Fire!\n	 */\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(2);\n		// Note that scan is called automatically when the robot is moving.\n		// By calling it manually here, we make sure we generate another scan event if there\'s a robot on the next\n		// wall, so that we do not start moving up it until it\'s gone.\n		if (peek) {\n			scan();\n		}\n	}\n}\n',NULL),(17,'dani','Package4','Alien','Y','C:/robocode/robots/sampleex/Alien.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n *\n * @author Pavel Savara (original)\n */\npublic class Alien implements IBasicEvents, IBasicRobot, Runnable {\n\n	PrintStream out;\n	IStandardRobotPeer peer;\n\n	public Runnable getRobotRunnable() {\n		return this;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return this;\n	}\n\n	public void setPeer(IBasicRobotPeer iRobotPeer) {\n		peer = (IStandardRobotPeer) iRobotPeer;\n	}\n\n	public void setOut(PrintStream printStream) {\n		out = printStream;\n	}\n\n	public void run() {\n		while (true) {\n			peer.move(100); // Move ahead 100\n			peer.turnGun(Math.PI * 2); // Spin gun around\n			peer.move(-100); // Move back 100\n			peer.turnGun(Math.PI * 2); // Spin gun around\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		peer.setFire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n	}\n\n	public void onStatus(StatusEvent e) {}\n\n	public void onBulletHit(BulletHitEvent e) {}\n\n	public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n	public void onBulletMissed(BulletMissedEvent e) {}\n\n	public void onDeath(DeathEvent e) {}\n\n	public void onHitRobot(HitRobotEvent e) {}\n\n	public void onHitWall(HitWallEvent e) {}\n\n	public void onRobotDeath(RobotDeathEvent e) {}\n\n	public void onWin(WinEvent e) {}\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n *\n * @author Pavel Savara (original)\n */\npublic class Alien implements IBasicEvents, IBasicRobot, Runnable {\n\n	PrintStream out;\n	IStandardRobotPeer peer;\n\n	public Runnable getRobotRunnable() {\n		return this;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return this;\n	}\n\n	public void setPeer(IBasicRobotPeer iRobotPeer) {\n		peer = (IStandardRobotPeer) iRobotPeer;\n	}\n\n	public void setOut(PrintStream printStream) {\n		out = printStream;\n	}\n\n	public void run() {\n		while (true) {\n			peer.move(100); // Move ahead 100\n			peer.turnGun(Math.PI * 2); // Spin gun around\n			peer.move(-100); // Move back 100\n			peer.turnGun(Math.PI * 2); // Spin gun around\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		peer.setFire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n	}\n\n	public void onStatus(StatusEvent e) {}\n\n	public void onBulletHit(BulletHitEvent e) {}\n\n	public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n	public void onBulletMissed(BulletMissedEvent e) {}\n\n	public void onDeath(DeathEvent e) {}\n\n	public void onHitRobot(HitRobotEvent e) {}\n\n	public void onHitWall(HitWallEvent e) {}\n\n	public void onRobotDeath(RobotDeathEvent e) {}\n\n	public void onWin(WinEvent e) {}\n}\n',NULL),(18,'diego','Package5','AlienComposition','Y','C:/robocode/robots/sampleex/AlienComposition.java','','Fri Dec 18 15:57:54 CST 2015','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n * This composition version is showing possible decomposition of robot, main runnable and event handler to different classes.\n *\n * @author Pavel Savara (original)\n */\npublic class AlienComposition implements IBasicRobot {\n	PrintStream out;\n	IStandardRobotPeer peer;\n	final AlienMain main;\n	final AlienEventHandler handler;\n\n	public AlienComposition() {\n		main = new AlienMain();\n		handler = new AlienEventHandler();\n	}\n\n	public void setPeer(IBasicRobotPeer iRobotPeer) {\n		peer = (IStandardRobotPeer) iRobotPeer;\n	}\n\n	public void setOut(PrintStream printStream) {\n		out = printStream;\n	}\n\n	public Runnable getRobotRunnable() {\n		return main;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return handler;\n	}\n\n	class AlienMain implements Runnable {\n		public void run() {\n			while (true) {\n				peer.move(100); // Move ahead 100\n				peer.turnGun(Math.PI * 2); // Spin gun around\n				peer.move(-100); // Move back 100\n				peer.turnGun(Math.PI * 2); // Spin gun around\n			}\n		}\n	}\n\n\n	class AlienEventHandler implements IBasicEvents {\n		public void onScannedRobot(ScannedRobotEvent e) {\n			peer.setFire(1);\n		}\n\n		public void onHitByBullet(HitByBulletEvent e) {\n			peer.turnBody(Math.PI / 2   e.getBearingRadians());\n		}\n\n		public void onStatus(StatusEvent e) {}\n\n		public void onBulletHit(BulletHitEvent e) {}\n\n		public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n		public void onBulletMissed(BulletMissedEvent e) {}\n\n		public void onDeath(DeathEvent e) {}\n\n		public void onHitRobot(HitRobotEvent e) {}\n\n		public void onHitWall(HitWallEvent e) {}\n\n		public void onRobotDeath(RobotDeathEvent e) {}\n\n		public void onWin(WinEvent e) {}\n	}\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.*;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IBasicRobot;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\nimport robocode.robotinterfaces.peer.IStandardRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * A sample robot.\n * Is not inherited from classic base robots, uses new experimental access to RobotPeer.\n * Use -DEXPERIMENTAL=true to start robocode for this robot.\n * This composition version is showing possible decomposition of robot, main runnable and event handler to different classes.\n *\n * @author Pavel Savara (original)\n */\npublic class AlienComposition implements IBasicRobot {\n	PrintStream out;\n	IStandardRobotPeer peer;\n	final AlienMain main;\n	final AlienEventHandler handler;\n\n	public AlienComposition() {\n		main = new AlienMain();\n		handler = new AlienEventHandler();\n	}\n\n	public void setPeer(IBasicRobotPeer iRobotPeer) {\n		peer = (IStandardRobotPeer) iRobotPeer;\n	}\n\n	public void setOut(PrintStream printStream) {\n		out = printStream;\n	}\n\n	public Runnable getRobotRunnable() {\n		return main;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return handler;\n	}\n\n	class AlienMain implements Runnable {\n		public void run() {\n			while (true) {\n				peer.move(100); // Move ahead 100\n				peer.turnGun(Math.PI * 2); // Spin gun around\n				peer.move(-100); // Move back 100\n				peer.turnGun(Math.PI * 2); // Spin gun around\n			}\n		}\n	}\n\n\n	class AlienEventHandler implements IBasicEvents {\n		public void onScannedRobot(ScannedRobotEvent e) {\n			peer.setFire(1);\n		}\n\n		public void onHitByBullet(HitByBulletEvent e) {\n			peer.turnBody(Math.PI / 2 + e.getBearingRadians());\n		}\n\n		public void onStatus(StatusEvent e) {}\n\n		public void onBulletHit(BulletHitEvent e) {}\n\n		public void onBulletHitBullet(BulletHitBulletEvent e) {}\n\n		public void onBulletMissed(BulletMissedEvent e) {}\n\n		public void onDeath(DeathEvent e) {}\n\n		public void onHitRobot(HitRobotEvent e) {}\n\n		public void onHitWall(HitWallEvent e) {}\n\n		public void onRobotDeath(RobotDeathEvent e) {}\n\n		public void onWin(WinEvent e) {}\n	}\n}\n\n',NULL),(19,'monica','Package','MasterAndSlave','Y','C:/robocode/robots/sampleex/MasterAndSlave.java','','','/**\n * Copyright (c) 2001-2014 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.robotinterfaces.IAdvancedEvents;\nimport robocode.robotinterfaces.IAdvancedRobot;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IInteractiveEvents;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * @author Pavel Savara (original)\n */\npublic class MasterAndSlave extends MasterBase implements IAdvancedRobot {\n\n	/**\n	 * This is not showing any aditional qualities over normal MyFirst robot.\n	 * But it could, because architecture is no more tied by inheritance from Robot base class.\n	 */\n	public void run() {\n		while (true) {\n			ahead(100); // Move ahead 100\n			turnGunRight(360); // Spin gun around\n			back(100); // Move back 100\n			turnGunRight(360); // Spin gun around\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		turnLeft(90 - e.getBearing());\n	}\n\n	public IInteractiveEvents getInteractiveEventListener() {\n		return null;\n	}\n}\n\n\n/**\n * Infrastructure base class, for helpers and boring implementation details\n */\nabstract class MasterBase {\n\n	public MasterBase() {\n		helperRobot = new Slave(this);\n	}\n\n	private final AdvancedRobot helperRobot;\n\n	public IAdvancedEvents getAdvancedEventListener() {\n		return helperRobot;\n	}\n\n	public IInteractiveEvents getSystemEventListener() {\n		return helperRobot;\n	}\n\n	public Runnable getRobotRunnable() {\n		return helperRobot;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return helperRobot;\n	}\n\n	public void setPeer(IBasicRobotPeer robotPeer) {\n		helperRobot.setPeer(robotPeer);\n	}\n\n	public void setOut(PrintStream printStream) {\n		helperRobot.setOut(printStream);\n	}\n\n	public void turnGunRight(double degrees) {\n		helperRobot.turnGunRight(degrees);\n	}\n\n	public void turnLeft(double degrees) {\n		helperRobot.turnLeft(degrees);\n	}\n\n	public void ahead(double distance) {\n		helperRobot.ahead(distance);\n	}\n\n	public void back(double distance) {\n		helperRobot.back(distance);\n	}\n\n	public void fire(double power) {\n		helperRobot.fire(power);\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {}\n\n	public void onHitByBullet(HitByBulletEvent e) {}\n\n	public void run() {}\n}','/**\n * Copyright (c) 2001-2016 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://robocode.sourceforge.net/license/epl-v10.html\n */\npackage sampleex;\n\n\nimport robocode.AdvancedRobot;\nimport robocode.HitByBulletEvent;\nimport robocode.ScannedRobotEvent;\nimport robocode.robotinterfaces.IAdvancedEvents;\nimport robocode.robotinterfaces.IAdvancedRobot;\nimport robocode.robotinterfaces.IBasicEvents;\nimport robocode.robotinterfaces.IInteractiveEvents;\nimport robocode.robotinterfaces.peer.IBasicRobotPeer;\n\nimport java.io.PrintStream;\n\n\n/**\n * @author Pavel Savara (original)\n */\npublic class MasterAndSlave extends MasterBase implements IAdvancedRobot {\n\n	/**\n	 * This is not showing any aditional qualities over normal MyFirst robot.\n	 * But it could, because architecture is no more tied by inheritance from Robot base class.\n	 */\n	public void run() {\n		while (true) {\n			ahead(100); // Move ahead 100\n			turnGunRight(360); // Spin gun around\n			back(100); // Move back 100\n			turnGunRight(360); // Spin gun around\n		}\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {\n		fire(1);\n	}\n\n	public void onHitByBullet(HitByBulletEvent e) {\n		turnLeft(90 - e.getBearing());\n	}\n\n	public IInteractiveEvents getInteractiveEventListener() {\n		return null;\n	}\n}\n\n\n/**\n * Infrastructure base class, for helpers and boring implementation details\n */\nabstract class MasterBase {\n\n	public MasterBase() {\n		helperRobot = new Slave(this);\n	}\n\n	private final AdvancedRobot helperRobot;\n\n	public IAdvancedEvents getAdvancedEventListener() {\n		return helperRobot;\n	}\n\n	public IInteractiveEvents getSystemEventListener() {\n		return helperRobot;\n	}\n\n	public Runnable getRobotRunnable() {\n		return helperRobot;\n	}\n\n	public IBasicEvents getBasicEventListener() {\n		return helperRobot;\n	}\n\n	public void setPeer(IBasicRobotPeer robotPeer) {\n		helperRobot.setPeer(robotPeer);\n	}\n\n	public void setOut(PrintStream printStream) {\n		helperRobot.setOut(printStream);\n	}\n\n	public void turnGunRight(double degrees) {\n		helperRobot.turnGunRight(degrees);\n	}\n\n	public void turnLeft(double degrees) {\n		helperRobot.turnLeft(degrees);\n	}\n\n	public void ahead(double distance) {\n		helperRobot.ahead(distance);\n	}\n\n	public void back(double distance) {\n		helperRobot.back(distance);\n	}\n\n	public void fire(double power) {\n		helperRobot.fire(power);\n	}\n\n	public void onScannedRobot(ScannedRobotEvent e) {}\n\n	public void onHitByBullet(HitByBulletEvent e) {}\n\n	public void run() {}\n}\n',NULL);
/*!40000 ALTER TABLE `robot` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `totalstat`
--

DROP TABLE IF EXISTS `totalstat`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `totalstat` (
  `Rank` int(11) DEFAULT NULL,
  `RobotName` varchar(30) DEFAULT NULL,
  `TotalScore` int(11) DEFAULT NULL,
  `PercentofTotal` int(11) DEFAULT NULL,
  `1sts` int(11) DEFAULT NULL,
  `2nds` int(11) DEFAULT NULL,
  `3rds` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `totalstat`
--

LOCK TABLES `totalstat` WRITE;
/*!40000 ALTER TABLE `totalstat` DISABLE KEYS */;
/*!40000 ALTER TABLE `totalstat` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `trial`
--

DROP TABLE IF EXISTS `trial`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `trial` (
  `robotname` varchar(255) DEFAULT NULL,
  `robotcode` text
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `trial`
--

LOCK TABLES `trial` WRITE;
/*!40000 ALTER TABLE `trial` DISABLE KEYS */;
/*!40000 ALTER TABLE `trial` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `userpackages`
--

DROP TABLE IF EXISTS `userpackages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `userpackages` (
  `userid` varchar(50) NOT NULL,
  `packagename` varchar(45) NOT NULL,
  PRIMARY KEY (`userid`,`packagename`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `userpackages`
--

LOCK TABLES `userpackages` WRITE;
/*!40000 ALTER TABLE `userpackages` DISABLE KEYS */;
INSERT INTO `userpackages` VALUES ('dana','Package3'),('dani','Package2'),('dani','Package4'),('david','Package3'),('diego','Package4'),('diego','Package5'),('mark','Package1'),('mark','Package2'),('marsh','Package1'),('marsh','Package2'),('marsh','Package3'),('mellisa','Package1'),('monica','Package2');
/*!40000 ALTER TABLE `userpackages` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-12-15 18:58:34
